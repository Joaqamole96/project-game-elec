// BiomeModel.cs

[System.Serializable]
public class BiomeModel
{
    public string Name;
    public int MinLevel;
    public int MaxLevel;
    // Biomes are randomly selected, so no weight is needed.
    // public float Weight;

    public BiomeModel(string name, int minLevel, int maxLevel/*, float weight = 1.0f*/)
    {
        Name = name;
        MinLevel = minLevel;
        MaxLevel = maxLevel;
        // Weight = weight;
    }
}

// CorridorModel.cs
using System.Collections.Generic;
using UnityEngine;

public class CorridorModel
{
    public List<Vector2Int> Tiles;
    public RoomModel StartRoom;
    public RoomModel EndRoom;
    public DoorModel StartDoor;
    public DoorModel EndDoor;

    public CorridorModel(List<Vector2Int> tiles, RoomModel startRoom, RoomModel endRoom, DoorModel startDoor, DoorModel endDoor)
    {
        Tiles = tiles;
        StartRoom = startRoom;
        EndRoom = endRoom;
        StartDoor = startDoor;
        EndDoor = endDoor;

        if ((StartRoom != null) && (EndRoom != null) && (StartRoom != EndRoom))
        {
            StartRoom.AddConnectedRoom(EndRoom);
            EndRoom.AddConnectedRoom(StartRoom);
        }
    }
}

// DoorModel.cs
using UnityEngine;

public class DoorModel
{
    public Vector2Int Position;
    public DoorState State;
    public DoorKey Key;

    public DoorModel(Vector2Int position, DoorState state = DoorState.Closed, DoorKey key = DoorKey.None)
    {
        Position = position;
        State = state;
        Key = key;
    }
}

// FloorModel.cs
using UnityEngine;

public class FloorModel
{
    public Vector2Int Position;
    public FloorType Type;

    public FloorModel(Vector2Int position, FloorType type = FloorType.Normal)
    {
        Position = position;
        Type = type;
    }
}

// LevelModel.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class LevelModel
{
    public int Width;
    public int Height;
    public List<RoomModel> Rooms;
    public List<CorridorModel> Corridors;
    public HashSet<Vector2Int> AllFloorTiles;
    public HashSet<Vector2Int> AllWallTiles;
    public HashSet<Vector2Int> AllDoorTiles;
    // public Dictionary<Vector2Int, WallType> WallTypes;
    public Dictionary<Vector2Int, DoorModel> GameplayDoors;
    public BoundsInt OverallBounds;

    private Dictionary<Vector2Int, RoomModel> _tileToRoomMap;
    private Dictionary<Vector2Int, CorridorModel> _tileToCorridorMap;
    private Dictionary<RoomModel, List<RoomModel>> _roomGraph;
    private bool _isInitialized = false;

    // NOTE: A Model file should not have this much logic. In fact, it should have no logic at all.
    public void InitializeSpatialData()
    {
        if (_isInitialized) 
            return;

        CalculateOverallBounds();
        BuildTileMaps();
        BuildRoomGraph();
        InitializeGameplayObjects();
        
        _isInitialized = true;
        
        Debug.Log($"Level spatial data initialized: {Rooms.Count} rooms, {Corridors.Count} corridors, {AllFloorTiles.Count} floor tiles");
    }

    private void CalculateOverallBounds()
    {
        if (Rooms.Count == 0) 
        {
            OverallBounds = new BoundsInt(0, 0, 0, 0, 0, 0);
            return;
        }
        
        int minX = Rooms.Min(r => r.Bounds.xMin);
        int maxX = Rooms.Max(r => r.Bounds.xMax);
        int minY = Rooms.Min(r => r.Bounds.yMin);
        int maxY = Rooms.Max(r => r.Bounds.yMax);
        
        OverallBounds = new BoundsInt(minX, minY, 0, maxX - minX, maxY - minY, 1);
    }
    
    private void BuildTileMaps()
    {
        _tileToRoomMap = new Dictionary<Vector2Int, RoomModel>();
        _tileToCorridorMap = new Dictionary<Vector2Int, CorridorModel>();
        
        BuildRoomTileMap();
        BuildCorridorTileMap();
    }

    private void BuildRoomTileMap()
    {
        foreach (var room in Rooms)
            foreach (var tile in room.GetFloorTiles())
                _tileToRoomMap[tile] = room;
    }

    private void BuildCorridorTileMap()
    {
        foreach (var corridor in Corridors.Where(c => c?.Tiles != null))
            foreach (var tile in corridor.Tiles)
            {
                _tileToCorridorMap[tile] = corridor;
                // Mark corridor tiles as not belonging to any room
                if (!_tileToRoomMap.ContainsKey(tile))
                    _tileToRoomMap[tile] = null;
            }
    }
    
    private void BuildRoomGraph()
    {
        _roomGraph = new Dictionary<RoomModel, List<RoomModel>>();
        
        foreach (var room in Rooms)
            _roomGraph[room] = new List<RoomModel>();
        
        // Add connections from corridors
        foreach (var corridor in Corridors.Where(IsValidCorridor))
        {
            AddRoomConnection(corridor.StartRoom, corridor.EndRoom);
            AddRoomConnection(corridor.EndRoom, corridor.StartRoom);
        }
    }

    private bool IsValidCorridor(CorridorModel corridor)
    {
        return (corridor?.StartRoom != null) && (corridor?.EndRoom != null);
    }

    private void AddRoomConnection(RoomModel roomA, RoomModel roomB)
    {
        if (_roomGraph.ContainsKey(roomA) && !_roomGraph[roomA].Contains(roomB))
            _roomGraph[roomA].Add(roomB);
    }
    
    private void InitializeGameplayObjects()
    {
        InitializeDoors();
    }

    private void InitializeDoors()
    {
        foreach (var doorPos in AllDoorTiles)
            GameplayDoors[doorPos] = new DoorModel(doorPos);
    }

    public RoomModel GetRoomAtPosition(Vector2Int position)
    {
        if (!_isInitialized) 
            InitializeSpatialData();
        _tileToRoomMap.TryGetValue(position, out var room);
        return room;
    }

    public Dictionary<RoomModel, List<RoomModel>> RoomGraph 
    { 
        get 
        {
            if (!_isInitialized) 
                InitializeSpatialData();
            return _roomGraph;
        } 
    }
}

// PartitionModel.cs
using System.Collections.Generic;
using UnityEngine;

public class PartitionModel
{
    public RectInt Bounds;
    public PartitionModel LeftChild;
    public PartitionModel RightChild;
    public RoomModel Room;
    public List<PartitionModel> Neighbors;
    public bool IsLeaf => LeftChild == null && RightChild == null;

    public PartitionModel(RectInt bounds)
    {
        Bounds = bounds;
        Neighbors = new List<PartitionModel>();
    }

    private void CollectLeaves(PartitionModel partition, List<PartitionModel> leaves)
    {
        if (partition == null) 
            return;
        else if (partition.IsLeaf)
            leaves.Add(partition);
        else
        {
            CollectLeaves(partition.LeftChild, leaves);
            CollectLeaves(partition.RightChild, leaves);
        }
    }
}

// PlayerModel.cs
using UnityEngine;

public class PlayerModel : IEntity
{
    public int MaxHealth = 100;
    public int Health { get; set; } = 100;
    public int Damage = 20;
    public float Range = 2f;
    public float AttackCooldown = 1f;
    public Vector2 Position;
    public float MovementSpeed = 10f;
    public float JumpHeight = 5f;
    public WeaponModel Weapon;
    public bool IsAlive { get; set; } = true;
    public bool IsActive { get; set; } = true;

    public PlayerModel() { }

    public void Die()
    {
        IsAlive = false;
        IsActive = false;
    }

    public void Equip(WeaponModel weapon)
    {
        Weapon = weapon;
        UpdateStats(/*Stats*/);
    }

    public void UpdateStats(/*Stats*/) { }
}

// RoomModel.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class RoomModel
{
    public RectInt Bounds;
    public int ID;
    public List<RoomModel> ConnectedRooms;
    public RoomType Type;
    public RoomAccess State;
    public int DistanceFromEntrance;
    public bool IsRevealed;
    public bool IsCleared;
    public List<Vector2Int> SpawnPositions;

    public Vector2Int Center => new(
        (Bounds.xMin + Bounds.xMax) / 2,
        (Bounds.yMin + Bounds.yMax) / 2
    );

    public RoomModel(RectInt bounds, int id, RoomType type)
    {
        Bounds = bounds;
        ID = id;
        ConnectedRooms = new List<RoomModel>();
        Type = type;
        State = GetDefaultStateForType(type);
        IsRevealed = type == RoomType.Entrance;
        IsCleared = type != RoomType.Combat && type != RoomType.Boss;
        SpawnPositions = new List<Vector2Int>();
    }

    public IEnumerable<Vector2Int> GetFloorTiles()
    {
        if (Bounds.width < 3 || Bounds.height < 3)
        {
            Debug.LogWarning($"Room {ID} bounds too small for floor tiles: {Bounds}");
            yield break;
        }

        for (int x = Bounds.xMin + 1; x < Bounds.xMax - 1; x++)
            for (int y = Bounds.yMin + 1; y < Bounds.yMax - 1; y++)
                yield return new Vector2Int(x, y);
    }

    public IEnumerable<Vector2Int> GetWallPerimeter()
    {
        for (int x = Bounds.xMin; x < Bounds.xMax; x++)
            yield return new Vector2Int(x, Bounds.yMax - 1);
        for (int x = Bounds.xMin; x < Bounds.xMax; x++)
            yield return new Vector2Int(x, Bounds.yMin);
        for (int y = Bounds.yMin; y < Bounds.yMax; y++)
            yield return new Vector2Int(Bounds.xMax - 1, y);
        for (int y = Bounds.yMin; y < Bounds.yMax; y++)
            yield return new Vector2Int(Bounds.xMin, y);
    }

    public bool ContainsPosition(Vector2Int position)
    {
        return position.x >= Bounds.xMin &&
            position.x < Bounds.xMax &&
            position.y >= Bounds.yMin &&
            position.y < Bounds.yMax;
    }

    public IEnumerable<Vector2Int> GetInnerTiles(int padding = 1)
    {
        for (int x = Bounds.xMin + padding; x < Bounds.xMax - padding; x++)
            for (int y = Bounds.yMin + padding; y < Bounds.yMax - padding; y++)
                yield return new Vector2Int(x, y);
    }
    
    public void AddConnectedRoom(RoomModel room)
    {
        if (room != null && room != this && !ConnectedRooms.Contains(room))
            ConnectedRooms.Add(room);
    }

    public void GenerateSpawnPositions(int count, int padding = 2)
    {
        var innerTiles = GetInnerTiles(padding).ToList();
        if (innerTiles.Count == 0) return;
        
        SpawnPositions.Clear();
        var usedPositions = new HashSet<Vector2Int>();
        
        for (int i = 0; i < Mathf.Min(count, innerTiles.Count); i++)
        {
            Vector2Int spawnPos = FindValidSpawnPosition(innerTiles, usedPositions);
            if (spawnPos != Vector2Int.zero)
            {
                SpawnPositions.Add(spawnPos);
                usedPositions.Add(spawnPos);
            }
        }
    }

    private Vector2Int FindValidSpawnPosition(List<Vector2Int> availableTiles, HashSet<Vector2Int> usedPositions)
    {
        int attempts = 0;
        Vector2Int spawnPos;
        
        do {
            spawnPos = availableTiles[Random.Range(0, availableTiles.Count)];
            attempts++;
        } while (usedPositions.Contains(spawnPos) && attempts < 10);
        
        return attempts < 10 ? spawnPos : Vector2Int.zero;
    }

    public Vector2Int GetRandomSpawnPosition()
    {
        if (SpawnPositions.Count == 0) return Center;
        return SpawnPositions[Random.Range(0, SpawnPositions.Count)];
    }

    public void MarkAsCleared()
    {
        IsCleared = true;
        if (State == RoomAccess.Closed)
            State = RoomAccess.Open;
    }

    private RoomAccess GetDefaultStateForType(RoomType type)
    {
        return type switch 
        { 
            RoomType.Combat or RoomType.Boss => RoomAccess.Closed, 
            _ => RoomAccess.Open 
        };
    }
}

// WallModel.cs
using UnityEngine;

public class WallModel
{
    public Vector2Int Position { get; private set; }

    public WallModel(Vector2Int position)
    {
        Position = position;
    }
}

// WeaponModel.cs
using System.Collections.Generic;
using UnityEngine;

public class WeaponModel
{
    public string Name;
    public WeaponRarity Rarity;

    public static List<WeaponModel> Weapons = new()
    {
        new("Iron Sword", WeaponRarity.Common),
        new("Stone Hammer", WeaponRarity.Common),
        new("Wooden Bow", WeaponRarity.Common),
        new("Sling", WeaponRarity.Common),
    };

    public WeaponModel(string name, WeaponRarity rarity)
    {
        Name = name;
        Rarity = rarity;
    }

    public WeaponModel GetWeaponByName(string name)
    {
        return Weapons.Find(weapon => weapon.Name == name);
    }

    public WeaponModel GetRandomWeaponByRarity(WeaponRarity rarity)
    {
        var filteredWeapons = Weapons.FindAll(weapon => weapon.Rarity == rarity);
        if (filteredWeapons.Count == 0) 
            return null;
        var randomIndex = Random.Range(0, filteredWeapons.Count);
        return filteredWeapons[randomIndex];
    }
}