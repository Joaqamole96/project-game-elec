using UnityEngine;
using System;
using System.Collections.Generic;

public class BiomeManager
{
    public List<BiomeModel> Biomes = new List<BiomeModel>();

    private System.Random _random;
    private Dictionary<string, GameObject> _prefabCache;

    // -------------------------------------------------- //

    public BiomeManager(LevelConfig levelConfig)
    {
        if (levelConfig == null)
            throw new Exception("BiomeManager(): LevelConfig cannot be null.");

        _random = new System.Random(levelConfig.Seed);
        _prefabCache = new Dictionary<string, GameObject>(); // Initialize the cache
        InitializeBiomes();
        
        Debug.Log("BiomeManager initialized with prefab cache");
    }

    private void InitializeBiomes()
    {
        // Don't initialize a Default Biome; Default is for testing only.
        // Biomes.Add(new BiomeModel("Default", 1, 5));
        // NOTE: Provisionary biomes; may change in the future.
        Biomes.Add(new BiomeModel("Grasslands", 1, 5));
        Biomes.Add(new BiomeModel("Catacombs", 6, 10));
        Biomes.Add(new BiomeModel("Pits", 11, 15));
        
        Debug.Log($"BiomeManager: Initialized {Biomes.Count} biomes");
    }

    // -------------------------------------------------- //

    public BiomeModel GetBiomeForFloor(int floorLevel)
    {
        var candidateBiomes = Biomes.FindAll(biome => (floorLevel >= biome.MinLevel) && (floorLevel <= biome.MaxLevel));

        if (candidateBiomes.Count == 0)
            throw new Exception($"BiomeManager.GetBiomeForFloor(): No candidate biome found for floor {floorLevel}.");

        int selectedBiomeIndex = _random.Next(0, candidateBiomes.Count);
        var selectedBiome = candidateBiomes[selectedBiomeIndex];

        Debug.Log($"BiomeManager.GetBiomeForFloor(): Returning {selectedBiome.Name} for floor {floorLevel}");
        return selectedBiome;
    }

    // -------------------------------------------------- //

    public GameObject GetPrefab(string prefabPath)
    {
        if (string.IsNullOrEmpty(prefabPath))
            throw new Exception("BiomeManager.GetPrefab(): Empty prefab path provided!");
        
        if (_prefabCache == null)
        {
            Debug.LogWarning("Prefab cache was null, reinitializing...");
            _prefabCache = new Dictionary<string, GameObject>();
        }
        
        if (_prefabCache.TryGetValue(prefabPath, out GameObject cachedPrefab))
        {
            if (cachedPrefab != null)
            {
                Debug.Log($"BiomeManager.GetPrefab(): Returning cached {cachedPrefab.name}");
                return cachedPrefab;
            }
            else
            {
                // Remove null entry from cache
                _prefabCache.Remove(prefabPath);
            }
        }
        
        return GetAndCachePrefab(prefabPath);
    }

    public GameObject GetFloorPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetFloorPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/FloorPrefab");
    }

    public GameObject GetWallPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetWallPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/WallPrefab");
    }

    public GameObject GetDoorPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetDoorPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/DoorPrefab");
    }

    public GameObject GetCeilingPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetCeilingPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/CeilingPrefab");
    }

    // Prop prefab methods for PropRenderer
    public GameObject GetEntrancePropPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetEntrancePropPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/Props/EntranceProp");
    }

    public GameObject GetExitPropPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetExitPropPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/Props/ExitProp");
    }

    public GameObject GetShopPropPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetShopPropPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/Props/ShopProp");
    }

    public GameObject GetTreasurePropPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetTreasurePropPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/Props/TreasureProp");
    }

    public GameObject GetBossPropPrefab(BiomeModel biome)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetBossPropPrefab(): Biome cannot be null!");
            
        return GetPrefab($"Biomes/{biome.Name}/Props/BossProp");
    }

    // Decor prefab methods for DecorRenderer
    public GameObject GetDecorPrefab(BiomeModel biome, string decorType)
    {
        if (biome == null)
            throw new Exception("BiomeManager.GetDecorPrefab(): Biome cannot be null!");
            
        if (string.IsNullOrEmpty(decorType))
            throw new Exception("BiomeManager.GetDecorPrefab(): Decor type cannot be null or empty!");
            
        return GetPrefab($"Biomes/{biome.Name}/Decor/{decorType}");
    }

    public DecorConfig GetRoomDecorConfig(BiomeModel biome, RoomType roomType)
    {
        // Return biome-specific decor configuration
        // This can be expanded to have different decor configs per room type
        return new DecorConfig
        {
            MinDensity = 0.1f,
            MaxDensity = 0.3f,
            UseMeshCombining = true,
            PrefabWeights = new Dictionary<string, float>
            {
                { "Tree", 0.3f },
                { "Rock", 0.4f },
                { "Bush", 0.3f }
            }
        };
    }

    public DecorConfig GetCorridorDecorConfig(BiomeModel biome)
    {
        // Less dense decor in corridors
        return new DecorConfig
        {
            MinDensity = 0.05f,
            MaxDensity = 0.15f,
            UseMeshCombining = true,
            PrefabWeights = new Dictionary<string, float>
            {
                { "Rock", 0.6f },
                { "Bush", 0.4f }
            }
        };
    }

    private GameObject GetAndCachePrefab(string prefabPath)
    {
        GameObject prefab = Resources.Load<GameObject>(prefabPath);

        if (prefab == null)
        {
            // Log available resources for debugging
            LogAvailableResources(prefabPath);
            throw new Exception($"BiomeManager.GetAndCachePrefab(): Prefab not found at path: {prefabPath}");
        }

        if (_prefabCache == null)
        {
            _prefabCache = new Dictionary<string, GameObject>();
        }

        _prefabCache[prefabPath] = prefab;
        Debug.Log($"BiomeManager.GetAndCachePrefab(): Cached {prefab.name} from path: {prefabPath}");

        return prefab;
    }

    // -------------------------------------------------- //

    private void LogAvailableResources(string failedPath)
    {
        // Extract biome name from failed path for more targeted logging
        string biomeName = "Default"; // fallback
        try
        {
            var pathParts = failedPath.Split('/');
            if (pathParts.Length >= 2 && pathParts[0] == "Biomes")
            {
                biomeName = pathParts[1];
            }
        }
        catch (System.Exception e)
        {
            Debug.LogWarning($"Failed to parse biome name from path: {e.Message}");
        }

        var availableResources = Resources.LoadAll<GameObject>($"Biomes/{biomeName}");
        Debug.Log($"Available resources in Biomes/{biomeName}: {availableResources.Length}");
        foreach (var resource in availableResources)
            Debug.Log($" - {resource.name} (Type: {resource.GetType()})");

        // Also check if the specific prefab exists
        var specificPrefab = Resources.Load<GameObject>(failedPath);
        if (specificPrefab != null)
        {
            Debug.Log($"SUCCESS: Prefab found at {failedPath}: {specificPrefab.name}");
        }
        else
        {
            Debug.LogError($"FAILED: Prefab not found at {failedPath}");
        }
    }

    /// <summary>
    /// Clears the prefab cache to free memory.
    /// </summary>
    public void ClearCache()
    {
        if (_prefabCache != null)
        {
            _prefabCache.Clear();
            Debug.Log("BiomeManager: Prefab cache cleared");
        }
    }

    /// <summary>
    /// Gets the number of prefabs currently cached.
    /// </summary>
    public int GetCacheSize()
    {
        return _prefabCache?.Count ?? 0;
    }
}

using UnityEngine;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Debug = UnityEngine.Debug;

[RequireComponent(typeof(DungeonRenderer))]
public class DungeonManager : MonoBehaviour
{
    [Header("Configuration Files")]
    public GameConfig GameConfig;
    public LevelConfig LevelConfig;
    public PartitionConfig PartitionConfig;
    
    [Header("Dependencies")]
    public DungeonRenderer DungeonRenderer;
    
    // Generator components
    private PartitionGenerator _partitionGenerator;
    private RoomGenerator _roomGenerator;
    private CorridorGenerator _corridorGenerator;
    private LayoutGenerator _layoutGenerator;
    private BiomeManager _biomeManager;
    
    // Runtime state
    private LevelModel _layout;
    private List<RoomModel> _rooms;
    private System.Random _random;
    private ConfigRegistry _configRegistry;
    
    // Runtime config accessors
    private GameConfig RuntimeGameConfig => _configRegistry?.GameConfig ?? GameConfig;
    private LevelConfig RuntimeLevelConfig => _configRegistry?.LevelConfig ?? LevelConfig;
    private PartitionConfig RuntimePartitionConfig => _configRegistry?.PartitionConfig ?? PartitionConfig;
    
    public List<RoomModel> CurrentRooms => _rooms;
    public LevelModel CurrentLayout => _layout;
    
    void Awake()
    {
        InitializeComponents();
        InitializeConfigRegistry();
        InitializeRandom();
    }

    void Start() => GenerateDungeon();

    private void InitializeConfigRegistry()
    {
        _configRegistry = new ConfigRegistry(GameConfig, LevelConfig, PartitionConfig, RoomConfig);
        Debug.Log($"DungeonManager.InitializeConfigRegistry(): Runtime configs initialized - Starting floor: {RuntimeLevelConfig.LevelNumber}");
    }

    private void InitializeComponents()
    {
        _partitionGenerator = new PartitionGenerator();
        _roomGenerator = new RoomGenerator();
        _corridorGenerator = new CorridorGenerator();
        _layoutGenerator = new LayoutGenerator();
        _biomeManager = new BiomeManager(LevelConfig);
        
        DungeonRenderer = GetComponent<DungeonRenderer>();
        DungeonRenderer.Initialize(_biomeManager);
        
        Debug.Log("DungeonManager: All components initialized");
    }

    private void EnsureComponentsInitialized()
    {
        if (_partitionGenerator == null)
            InitializeComponents();
    }

    [ContextMenu("Generate Dungeon")]
    public void GenerateDungeon()
    {
        EnsureComponentsInitialized();
        InitializeRandom();
        
        var stopwatch = Stopwatch.StartNew();
        ClearPreviousGeneration();
        ValidateConfigs();
        
        Debug.Log($"Generating floor {RuntimeLevelConfig.LevelNumber}");
        
        ExecuteGenerationPipeline();
        
        stopwatch.Stop();
        Debug.Log($"Generated Floor {RuntimeLevelConfig.LevelNumber}: {GetRoomTypeBreakdown()} in {stopwatch.ElapsedMilliseconds}ms");
    }

    private void ExecuteGenerationPipeline()
    {
        // Get biome for this floor
        var biome = _biomeManager.GetBiomeForFloor(RuntimeLevelConfig.LevelNumber);
        
        // Phase 1: Generate layout
        _layout = GenerateDungeonLayout();
        if (_layout == null)
        {
            Debug.LogError("Dungeon generation failed: Layout is null");
            return;
        }

        // Phase 2: Render dungeon
        RenderDungeon(biome);
        
        // Phase 3: Notify systems
        NotifyDungeonReady();
    }

    private void RenderDungeon(BiomeModel biome)
    {
        if (DungeonRenderer != null)
        {
            DungeonRenderer.RenderDungeon(_layout, _layout.Rooms, biome);
        }
        else
        {
            Debug.LogError("DungeonRenderer is not assigned!");
        }
    }

    private void NotifyDungeonReady()
    {
        GetComponent<PlayerSpawner>()?.OnDungeonGenerated();
    }

    [ContextMenu("Next Floor")]
    public void GenerateNextFloor()
    {
        RuntimeLevelConfig.LevelNumber++;
        _random = new System.Random(RuntimeLevelConfig.Seed + RuntimeLevelConfig.LevelNumber);

        if (RuntimeLevelConfig.LevelNumber > 1)
        {
            GrowFloorSize();
        }

        Debug.Log($"Moving to floor {RuntimeLevelConfig.LevelNumber}");
        GenerateDungeon();
    }

    private void GrowFloorSize()
    {
        bool growWidth = _random.NextDouble() > 0.5;
        if (growWidth)
        {
            RuntimeLevelConfig.Width = Mathf.Min(RuntimeLevelConfig.Width + RuntimeLevelConfig.Growth, RuntimeLevelConfig.MaxSize);
        }
        else
        {
            RuntimeLevelConfig.Height = Mathf.Min(RuntimeLevelConfig.Height + RuntimeLevelConfig.Growth, RuntimeLevelConfig.MaxSize);
        }
    }

    private LevelModel GenerateDungeonLayout()
    {
        var layout = new LevelModel();
        
        // Generate partitions
        var root = _partitionGenerator.GeneratePartitionTree(RuntimeLevelConfig, RuntimePartitionConfig, _random);
        var leaves = _partitionGenerator.CollectLeafPartitions(root);
        
        // Create rooms from partitions
        var rooms = _roomGenerator.CreateRoomsFromPartitions(leaves, _random);
        if (rooms == null || rooms.Count == 0)
        {
            Debug.LogError("Failed to create rooms from partitions");
            return null;
        }
        
        // Find neighbors for corridor generation
        _roomGenerator.FindAndAssignNeighbors(leaves);
        
        // Generate corridors
        var allCorridors = _corridorGenerator.GenerateTotalCorridors(leaves, _random);
        layout.Corridors = MinimumSpanningTree.Apply(allCorridors, rooms);
        
        // Generate layout geometry (floors, walls, doors)
        layout = _layoutGenerator.GenerateLayoutGeometry(rooms, layout.Corridors);
        
        // Assign room types with sophisticated logic
        _roomGenerator.AssignRoomTypes(rooms, RuntimeLevelConfig.LevelNumber, _random);
        
        layout.Rooms = rooms;
        
        Debug.Log($"Dungeon layout generated: {rooms.Count} rooms, {layout.Corridors.Count} corridors");
        return layout;
    }

    #region Helper Methods
    private void InitializeRandom() => _random ??= new System.Random(RuntimeLevelConfig.Seed);

    private void ValidateConfigs()
    {
        RuntimeLevelConfig.Width = Mathf.Clamp(RuntimeLevelConfig.Width, 10, 1000);
        RuntimeLevelConfig.Height = Mathf.Clamp(RuntimeLevelConfig.Height, 10, 1000);
        RuntimePartitionConfig.MinSize = Mathf.Max(3, RuntimePartitionConfig.MinSize);
        RuntimeRoomConfig.MinRoomSize = Mathf.Max(3, RuntimeRoomConfig.MinRoomSize);
    }

    private void ClearPreviousGeneration()
    {
        _layout = null;
        _rooms = null;
        DungeonRenderer?.ClearRendering();
    }

    private string GetRoomTypeBreakdown()
    {
        if (_layout?.Rooms == null) return "No rooms";
        return string.Join(", ", _layout.Rooms.GroupBy(r => r.Type).Select(g => $"{g.Key}: {g.Count()}"));
    }

    /// <summary>
    /// Gets the world position of the entrance room for player spawning.
    /// </summary>
    public Vector3 GetEntranceRoomPosition()
    {
        if (_layout?.Rooms == null) 
        {
            Debug.LogWarning("GetEntranceRoomPosition: Rooms is null");
            return Vector3.zero;
        }
        
        var entrance = _layout.Rooms.FirstOrDefault(room => room.Type == RoomType.Entrance);
        if (entrance == null)
        {
            Debug.LogWarning("GetEntranceRoomPosition: No entrance room found");
            LogAvailableRooms();
            return Vector3.zero;
        }

        Vector2Int spawnTile = entrance.Center;
        Vector3 spawnPosition = new Vector3(spawnTile.x + 0.5f, 1f, spawnTile.y + 0.5f);
        
        Debug.Log($"Spawning at entrance room center: {spawnTile} -> {spawnPosition}");
        return spawnPosition;
    }

    private void LogAvailableRooms()
    {
        if (_layout?.Rooms == null) 
        {
            Debug.LogWarning("No rooms available");
            return;
        }
        Debug.LogWarning($"Available rooms: {_layout.Rooms.Count}, Types: {string.Join(", ", _layout.Rooms.Select(r => r.Type))}");
    }
    #endregion
}

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Main orchestrator for dungeon rendering using the new consolidated rendering systems.
/// Handles layout, props, decor, and environment rendering.
/// </summary>
public class DungeonRenderer : MonoBehaviour
{
    [Header("Rendering Settings")]
    public bool EnableCollision = true;
    public bool EnableCeiling = true;
    public bool EnableVoid = true;
    
    [Header("Parent Transforms")]
    public Transform LayoutParent;
    public Transform PropsParent;
    public Transform DecorParent;
    public Transform EnvironmentParent;
    
    // Consolidated rendering systems
    private LayoutRenderer _layoutRenderer;
    private PropRenderer _propRenderer;
    private DecorRenderer _decorRenderer;
    private BiomeManager _biomeManager;

    private bool _isInitialized = false;

    /// <summary>
    /// Initializes the rendering systems with required dependencies.
    /// </summary>
    public void Initialize(BiomeManager biomeManager)
    {
        if (biomeManager == null)
        {
            Debug.LogError("DungeonRenderer.Initialize(): BiomeManager cannot be null");
            return;
        }

        _biomeManager = biomeManager;
        
        // Initialize consolidated rendering systems
        _layoutRenderer = new LayoutRenderer(_biomeManager);
        _propRenderer = new PropRenderer(_biomeManager);
        _decorRenderer = new DecorRenderer(_biomeManager);
        
        CreateParentContainers();
        _isInitialized = true;
        
        Debug.Log("DungeonRenderer: Rendering systems initialized successfully");
    }

    /// <summary>
    /// Renders the complete dungeon using the consolidated rendering systems.
    /// </summary>
    public void RenderDungeon(LevelModel layout, List<RoomModel> rooms, BiomeModel biome)
    {
        if (!_isInitialized)
        {
            Debug.LogError("DungeonRenderer not initialized. Call Initialize() first.");
            return;
        }

        if (layout == null)
        {
            Debug.LogError("DungeonRenderer.RenderDungeon(): Layout cannot be null");
            return;
        }

        if (biome == null)
        {
            Debug.LogError("DungeonRenderer.RenderDungeon(): Biome cannot be null");
            return;
        }

        Debug.Log($"Starting dungeon rendering for biome: {biome.Name}");

        try
        {
            // Render all components using consolidated systems
            RenderLayout(layout, biome);
            RenderProps(layout, rooms, biome);
            RenderDecor(layout, rooms, biome);
            RenderEnvironment(layout, biome);
            
            Debug.Log("Dungeon rendering completed successfully");
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Dungeon rendering failed: {e.Message}");
        }
    }

    /// <summary>
    /// Renders the structural layout (floors, walls, doors, ceiling, void).
    /// </summary>
    private void RenderLayout(LevelModel layout, BiomeModel biome)
    {
        if (_layoutRenderer == null)
        {
            Debug.LogError("LayoutRenderer is not initialized");
            return;
        }

        Debug.Log("Rendering layout...");
        _layoutRenderer.RenderCompleteLayout(layout, biome, LayoutParent);
    }

    /// <summary>
    /// Renders functional props (entrance, exit, shop, treasure, etc.).
    /// </summary>
    private void RenderProps(LevelModel layout, List<RoomModel> rooms, BiomeModel biome)
    {
        if (_propRenderer == null)
        {
            Debug.LogError("PropRenderer is not initialized");
            return;
        }

        if (rooms == null || rooms.Count == 0)
        {
            Debug.LogWarning("No rooms provided for prop rendering");
            return;
        }

        Debug.Log("Rendering props...");
        _propRenderer.RenderAllProps(layout, rooms, biome, PropsParent);
    }

    /// <summary>
    /// Renders decorative objects (trees, rocks, etc.).
    /// </summary>
    private void RenderDecor(LevelModel layout, List<RoomModel> rooms, BiomeModel biome)
    {
        if (_decorRenderer == null)
        {
            Debug.LogError("DecorRenderer is not initialized");
            return;
        }

        Debug.Log("Rendering decor...");
        _decorRenderer.RenderAllDecor(layout, rooms, biome, DecorParent);
    }

    /// <summary>
    /// Renders environment elements (ceiling, void plane).
    /// </summary>
    private void RenderEnvironment(LevelModel layout, BiomeModel biome)
    {
        if (!EnableCeiling && !EnableVoid) return;

        Debug.Log("Rendering environment...");
        
        if (EnableCeiling)
        {
            _layoutRenderer.RenderCeiling(layout, biome, EnvironmentParent);
        }
        
        if (EnableVoid)
        {
            _layoutRenderer.RenderVoidPlane(layout, biome, EnvironmentParent);
        }
    }

    /// <summary>
    /// Clears all rendered dungeon geometry.
    /// </summary>
    public void ClearRendering()
    {
        Debug.Log("Clearing dungeon rendering...");
        
        ClearChildObjects(LayoutParent);
        ClearChildObjects(PropsParent);
        ClearChildObjects(DecorParent);
        ClearChildObjects(EnvironmentParent);
        
        Debug.Log("Dungeon rendering cleared");
    }

    #region Utility Methods

    private void CreateParentContainers()
    {
        LayoutParent = CreateParentIfNull(LayoutParent, "Layout");
        PropsParent = CreateParentIfNull(PropsParent, "Props");
        DecorParent = CreateParentIfNull(DecorParent, "Decor");
        EnvironmentParent = CreateParentIfNull(EnvironmentParent, "Environment");
        
        // Set all parents as children of this transform
        LayoutParent.SetParent(transform);
        PropsParent.SetParent(transform);
        DecorParent.SetParent(transform);
        EnvironmentParent.SetParent(transform);
    }

    private Transform CreateParentIfNull(Transform parent, string name)
    {
        if (parent != null) return parent;
        
        var newParent = new GameObject(name).transform;
        newParent.SetParent(transform);
        newParent.localPosition = Vector3.zero;
        return newParent;
    }

    private void ClearChildObjects(Transform parent)
    {
        if (parent == null) return;

        for (int i = parent.childCount - 1; i >= 0; i--)
        {
            var child = parent.GetChild(i);
            if (child != null)
            {
                #if UNITY_EDITOR
                DestroyImmediate(child.gameObject);
                #else
                Destroy(child.gameObject);
                #endif
            }
        }
    }

    /// <summary>
    /// Gets the total number of rendered objects across all categories.
    /// </summary>
    public int GetTotalRenderedObjects()
    {
        int total = 0;
        total += LayoutParent?.childCount ?? 0;
        total += PropsParent?.childCount ?? 0;
        total += DecorParent?.childCount ?? 0;
        total += EnvironmentParent?.childCount ?? 0;
        return total;
    }

    /// <summary>
    /// Logs rendering statistics for debugging.
    /// </summary>
    public void LogRenderingStats()
    {
        Debug.Log($"Rendering Stats - Layout: {LayoutParent?.childCount ?? 0}, " +
                 $"Props: {PropsParent?.childCount ?? 0}, " +
                 $"Decor: {DecorParent?.childCount ?? 0}, " +
                 $"Environment: {EnvironmentParent?.childCount ?? 0}");
    }

    #endregion
}