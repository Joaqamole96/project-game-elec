// DecorRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Renders decorative non-functional objects: trees, rocks, barrels, etc.
/// Uses mesh combining for performance where appropriate.
/// Throws errors for missing assets - no fallbacks.
/// </summary>
public class DecorRenderer
{
    private BiomeManager _biomeManager;
    private MeshCombiner _meshCombiner;

    public DecorRenderer(BiomeManager biomeManager)
    {
        _biomeManager = biomeManager;
        _meshCombiner = new MeshCombiner();
    }

    /// <summary>
    /// Renders all decor objects for the level.
    /// </summary>
    public void RenderAllDecor(LevelModel layout, List<RoomModel> rooms, BiomeModel biome, Transform parent)
    {
        if (layout == null) throw new System.ArgumentNullException(nameof(layout));
        if (biome == null) throw new System.ArgumentNullException(nameof(biome));
        if (parent == null) throw new System.ArgumentNullException(nameof(parent));

        Debug.Log($"Starting decor rendering for biome: {biome.Name}");

        // Render room-specific decor
        if (rooms != null)
        {
            foreach (var room in rooms)
            {
                RenderRoomDecor(room, biome, parent);
            }
        }

        // Render corridor decor
        RenderCorridorDecor(layout, biome, parent);

        // Finalize combined meshes
        _meshCombiner.FinalizeRendering(parent);

        Debug.Log("Decor rendering completed");
    }

    /// <summary>
    /// Renders decorative objects for a specific room.
    /// </summary>
    public void RenderRoomDecor(RoomModel room, BiomeModel biome, Transform parent)
    {
        if (room == null) return;

        var decorConfig = _biomeManager.GetRoomDecorConfig(biome, room.Type);
        if (decorConfig == null) return;

        int decorCount = CalculateRoomDecorCount(room, decorConfig);
        
        for (int i = 0; i < decorCount; i++)
        {
            var decorType = GetRandomDecorType(decorConfig);
            var decorPrefab = _biomeManager.GetDecorPrefab(biome, decorType);
            
            if (decorPrefab == null)
                throw new System.MissingReferenceException($"Decor prefab not found for type: {decorType} in biome: {biome.Name}");

            Vector3 position = CalculateRoomDecorPosition(room, decorPrefab, i);
            Quaternion rotation = CalculateDecorRotation(decorType);

            if (decorConfig.UseMeshCombining)
            {
                // Add to mesh combiner for batch rendering
                AddDecorToCombiner(decorPrefab, position, rotation);
            }
            else
            {
                // Instantiate as individual object
                CreateIndividualDecor(decorPrefab, position, rotation, parent, $"{decorType}_Room{room.ID}_{i}");
            }
        }
    }

    /// <summary>
    /// Renders decorative objects in corridors.
    /// </summary>
    public void RenderCorridorDecor(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.AllFloorTiles == null) return;

        var corridorDecorConfig = _biomeManager.GetCorridorDecorConfig(biome);
        if (corridorDecorConfig == null) return;

        // Sample corridor positions for decor placement
        var corridorPositions = SampleCorridorPositions(layout, corridorDecorConfig.Density);

        foreach (var position in corridorPositions)
        {
            var decorType = GetRandomDecorType(corridorDecorConfig);
            var decorPrefab = _biomeManager.GetDecorPrefab(biome, decorType);
            
            if (decorPrefab == null)
                throw new System.MissingReferenceException($"Corridor decor prefab not found for type: {decorType} in biome: {biome.Name}");

            Vector3 worldPos = new Vector3(position.x + 0.5f, 0f, position.y + 0.5f);
            Quaternion rotation = CalculateDecorRotation(decorType);

            if (corridorDecorConfig.UseMeshCombining)
            {
                AddDecorToCombiner(decorPrefab, worldPos, rotation);
            }
            else
            {
                CreateIndividualDecor(decorPrefab, worldPos, rotation, parent, $"{decorType}_Corridor_{position.x}_{position.y}");
            }
        }
    }

    #region Helper Methods

    private int CalculateRoomDecorCount(RoomModel room, DecorConfig config)
    {
        int roomArea = room.Bounds.width * room.Bounds.height;
        float density = Random.Range(config.MinDensity, config.MaxDensity);
        return Mathf.RoundToInt(roomArea * density);
    }

    private List<Vector2Int> SampleCorridorPositions(LevelModel layout, float density)
    {
        var positions = new List<Vector2Int>();
        
        if (layout.AllFloorTiles == null) return positions;

        // Only use corridor tiles (not in rooms)
        foreach (var floorPos in layout.AllFloorTiles)
        {
            if (layout.GetRoomAtPosition(floorPos) == null && Random.value < density)
            {
                positions.Add(floorPos);
            }
        }

        return positions;
    }

    private string GetRandomDecorType(DecorConfig config)
    {
        if (config.PrefabWeights == null || config.PrefabWeights.Count == 0)
            return "Default";

        // Simple weighted random selection
        float totalWeight = 0f;
        foreach (var weight in config.PrefabWeights.Values)
        {
            totalWeight += weight;
        }

        float randomValue = Random.Range(0f, totalWeight);
        float currentWeight = 0f;

        foreach (var kvp in config.PrefabWeights)
        {
            currentWeight += kvp.Value;
            if (randomValue <= currentWeight)
            {
                return kvp.Key;
            }
        }

        return "Default";
    }

    private Vector3 CalculateRoomDecorPosition(RoomModel room, GameObject decorPrefab, int index)
    {
        // Calculate position within room bounds, avoiding walls and other objects
        var bounds = room.Bounds;
        
        // Leave 1-unit border from walls
        int minX = bounds.xMin + 1;
        int maxX = bounds.xMax - 1;
        int minY = bounds.yMin + 1;
        int maxY = bounds.yMax - 1;

        if (minX >= maxX || minY >= maxY) 
            return new Vector3(room.Center.x, 0f, room.Center.y);

        // Use index to create deterministic but varied positions
        float x = minX + (index % (maxX - minX)) + 0.5f;
        float z = minY + ((index * 7) % (maxY - minY)) + 0.5f; // Prime number for better distribution

        // Add small random offset for natural look
        x += Random.Range(-0.2f, 0.2f);
        z += Random.Range(-0.2f, 0.2f);

        return new Vector3(x, 0f, z);
    }

    private Quaternion CalculateDecorRotation(string decorType)
    {
        // Some decor types might have specific rotation logic
        // For example, trees might rotate randomly, while walls might have fixed orientation
        if (decorType.Contains("Tree") || decorType.Contains("Rock"))
        {
            return Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
        }
        
        return Quaternion.identity;
    }

    private void AddDecorToCombiner(GameObject decorPrefab, Vector3 position, Quaternion rotation)
    {
        Mesh decorMesh = GetPrefabMesh(decorPrefab);
        Material decorMaterial = GetPrefabMaterial(decorPrefab);
        Vector3 decorScale = decorPrefab.transform.localScale;

        if (decorMesh != null && decorMaterial != null)
        {
            _meshCombiner.AddMesh(decorMesh, position, rotation, decorScale, decorMaterial);
        }
    }

    private void CreateIndividualDecor(GameObject decorPrefab, Vector3 position, Quaternion rotation, Transform parent, string name)
    {
        var decor = GameObject.Instantiate(decorPrefab, position, rotation, parent);
        decor.name = name;

        // Ensure decor has collider if it's meant to be physical
        if (decor.GetComponent<Collider>() == null)
        {
            decor.AddComponent<BoxCollider>();
        }
    }

    private Mesh GetPrefabMesh(GameObject prefab)
    {
        if (prefab == null) return null;
        var meshFilter = prefab.GetComponentInChildren<MeshFilter>();
        return meshFilter != null ? meshFilter.sharedMesh : null;
    }

    private Material GetPrefabMaterial(GameObject prefab)
    {
        if (prefab == null) return null;
        var renderer = prefab.GetComponentInChildren<Renderer>();
        return renderer != null ? renderer.sharedMaterial : null;
    }

    #endregion
}

// Configuration for decor placement
[System.Serializable]
public class DecorConfig
{
    public float MinDensity = 0.1f;
    public float MaxDensity = 0.3f;
    public bool UseMeshCombining = true;
    public Dictionary<string, float> PrefabWeights = new Dictionary<string, float>();
}

// LayoutRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Renders all structural layout elements: Floors, Walls, Doors, Ceiling, and Void Plane.
/// Uses mesh combining for optimal performance and throws errors for missing assets.
/// </summary>
public class LayoutRenderer
{
    private BiomeManager _biomeManager;
    private MeshCombiner _meshCombiner;

    public LayoutRenderer(BiomeManager biomeManager)
    {
        _biomeManager = biomeManager;
        _meshCombiner = new MeshCombiner();
    }

    /// <summary>
    /// Renders the complete layout including floors, walls, doors, ceiling and void plane.
    /// </summary>
    public void RenderCompleteLayout(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout == null) throw new System.ArgumentNullException(nameof(layout));
        if (biome == null) throw new System.ArgumentNullException(nameof(biome));
        if (parent == null) throw new System.ArgumentNullException(nameof(parent));

        Debug.Log($"Starting complete layout rendering for biome: {biome.Name}");

        RenderFloors(layout, biome, parent);
        RenderWalls(layout, biome, parent);
        RenderDoors(layout, biome, parent);
        RenderCeiling(layout, biome, parent);
        RenderVoidPlane(layout, biome, parent);

        // Finalize all combined meshes
        _meshCombiner.FinalizeRendering(parent);
        
        Debug.Log("Complete layout rendering finished");
    }

    /// <summary>
    /// Renders all floor tiles using combined meshes for optimal performance.
    /// </summary>
    public void RenderFloors(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.AllFloorTiles == null) 
            throw new System.ArgumentNullException("Layout or AllFloorTiles is null");

        var floorPrefab = _biomeManager.GetFloorPrefab(biome);
        if (floorPrefab == null)
            throw new System.MissingReferenceException($"Floor prefab not found for biome: {biome.Name}");

        Mesh floorMesh = GetPrefabMesh(floorPrefab);
        Material floorMaterial = GetPrefabMaterial(floorPrefab);
        Vector3 floorScale = floorPrefab.transform.localScale;

        if (floorMesh == null)
            throw new System.MissingReferenceException($"Mesh not found on floor prefab for biome: {biome.Name}");

        if (floorMaterial == null)
            throw new System.MissingReferenceException($"Material not found on floor prefab for biome: {biome.Name}");

        int floorsProcessed = 0;
        foreach (var floorPos in layout.AllFloorTiles)
        {
            Vector3 worldPos = new Vector3(floorPos.x + 0.5f, 0f, floorPos.y + 0.5f);
            _meshCombiner.AddMesh(floorMesh, worldPos, Quaternion.identity, floorScale, floorMaterial);
            floorsProcessed++;
        }

        Debug.Log($"Processed {floorsProcessed} floor positions for combining");
    }

    /// <summary>
    /// Renders all wall tiles using combined meshes (walls are just walls - no types).
    /// </summary>
    public void RenderWalls(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.AllWallTiles == null)
            throw new System.ArgumentNullException("Layout or AllWallTiles is null");

        var wallPrefab = _biomeManager.GetWallPrefab(biome);
        if (wallPrefab == null)
            throw new System.MissingReferenceException($"Wall prefab not found for biome: {biome.Name}");

        Mesh wallMesh = GetPrefabMesh(wallPrefab);
        Material wallMaterial = GetPrefabMaterial(wallPrefab);
        Vector3 wallScale = wallPrefab.transform.localScale;

        if (wallMesh == null)
            throw new System.MissingReferenceException($"Mesh not found on wall prefab for biome: {biome.Name}");

        if (wallMaterial == null)
            throw new System.MissingReferenceException($"Material not found on wall prefab for biome: {biome.Name}");

        int wallsProcessed = 0;
        foreach (var wallPos in layout.AllWallTiles)
        {
            Vector3 worldPos = new Vector3(wallPos.x + 0.5f, 1f, wallPos.y + 0.5f);
            _meshCombiner.AddMesh(wallMesh, worldPos, Quaternion.identity, wallScale, wallMaterial);
            wallsProcessed++;
        }

        Debug.Log($"Processed {wallsProcessed} wall positions for combining");
    }

    /// <summary>
    /// Renders all door tiles as individual prefab instances (not combined).
    /// </summary>
    public void RenderDoors(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.AllDoorTiles == null)
            throw new System.ArgumentNullException("Layout or AllDoorTiles is null");

        var doorPrefab = _biomeManager.GetDoorPrefab(biome);
        if (doorPrefab == null)
            throw new System.MissingReferenceException($"Door prefab not found for biome: {biome.Name}");

        int doorsCreated = 0;
        foreach (var doorPos in layout.AllDoorTiles)
        {
            Vector3 worldPos = new Vector3(doorPos.x + 0.5f, 0f, doorPos.y + 0.5f);
            Quaternion rotation = GetDoorRotation(layout, doorPos);
            
            var door = GameObject.Instantiate(doorPrefab, worldPos, rotation, parent);
            door.name = $"Door_{doorPos.x}_{doorPos.y}";
            
            // Ensure DoorController is properly configured
            var doorController = door.GetComponent<DoorController>();
            if (doorController == null)
            {
                doorController = door.AddComponent<DoorController>();
            }

            doorsCreated++;
        }

        Debug.Log($"Created {doorsCreated} door instances");
    }

    /// <summary>
    /// Renders a ceiling plane above the entire dungeon.
    /// </summary>
    public void RenderCeiling(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.OverallBounds == null)
            throw new System.ArgumentNullException("Layout or OverallBounds is null");

        var ceilingPrefab = _biomeManager.GetCeilingPrefab(biome);
        if (ceilingPrefab != null)
        {
            // Use biome-specific ceiling prefab
            BoundsInt dungeonBounds = layout.OverallBounds;
            Vector3 center = new Vector3(dungeonBounds.center.x, 9f, dungeonBounds.center.y);
            var ceiling = GameObject.Instantiate(ceilingPrefab, center, Quaternion.identity, parent);
            ceiling.name = "Ceiling";
            
            // Scale to cover entire dungeon
            float scaleX = Mathf.Ceil(dungeonBounds.size.x);
            float scaleZ = Mathf.Ceil(dungeonBounds.size.y);
            ceiling.transform.localScale = new Vector3(scaleX, 1f, scaleZ);
        }
        else
        {
            // Fallback to procedural ceiling (one-sided mirror)
            CreateProceduralCeiling(layout, parent);
        }
    }

    /// <summary>
    /// Renders a void plane below the dungeon to catch falling objects.
    /// </summary>
    public void RenderVoidPlane(LevelModel layout, BiomeModel biome, Transform parent)
    {
        if (layout?.OverallBounds == null)
            throw new System.ArgumentNullException("Layout or OverallBounds is null");

        BoundsInt dungeonBounds = layout.OverallBounds;
        Vector3 center = new Vector3(dungeonBounds.center.x, -5f, dungeonBounds.center.y);
        
        GameObject voidPlane = GameObject.CreatePrimitive(PrimitiveType.Plane);
        voidPlane.name = "VoidPlane";
        voidPlane.transform.SetParent(parent);
        voidPlane.transform.position = center;
        
        // Scale to cover entire dungeon + large buffer
        float scaleX = Mathf.Ceil(dungeonBounds.size.x * 0.2f);
        float scaleZ = Mathf.Ceil(dungeonBounds.size.y * 0.2f);
        voidPlane.transform.localScale = new Vector3(scaleX, 1f, scaleZ);
        
        // Apply void material
        Renderer renderer = voidPlane.GetComponent<Renderer>();
        Material voidMaterial = new Material(Shader.Find("Standard"));
        voidMaterial.color = Color.black;
        voidMaterial.SetFloat("_Metallic", 0f);
        voidMaterial.SetFloat("_Glossiness", 0f);
        renderer.sharedMaterial = voidMaterial;

        // Remove collider - void shouldn't block movement
        GameObject.DestroyImmediate(voidPlane.GetComponent<Collider>());
    }

    #region Helper Methods

    private Mesh GetPrefabMesh(GameObject prefab)
    {
        if (prefab == null) return null;
        var meshFilter = prefab.GetComponentInChildren<MeshFilter>();
        return meshFilter != null ? meshFilter.sharedMesh : null;
    }

    private Material GetPrefabMaterial(GameObject prefab)
    {
        if (prefab == null) return null;
        var renderer = prefab.GetComponentInChildren<Renderer>();
        return renderer != null ? renderer.sharedMaterial : null;
    }

    private Quaternion GetDoorRotation(LevelModel layout, Vector2Int doorPos)
    {
        // Determine door orientation based on adjacent walls/rooms
        var adjacentRoom = FindAdjacentRoom(layout, doorPos);
        if (adjacentRoom != null)
        {
            return GetDoorRotationFromRoom(adjacentRoom, doorPos);
        }

        // Fallback: analyze adjacent tiles to guess orientation
        Vector2Int[] directions = new Vector2Int[]
        {
            new Vector2Int(0, 1),   // North
            new Vector2Int(0, -1),  // South  
            new Vector2Int(1, 0),   // East
            new Vector2Int(-1, 0)   // West
        };

        foreach (var dir in directions)
        {
            Vector2Int checkPos = doorPos + dir;
            bool isRoom = layout.GetRoomAtPosition(checkPos) != null;
            
            if (isRoom)
            {
                // Door should face OPPOSITE the room (toward corridor)
                return GetRotationFromDirection(-dir);
            }
        }

        // Ultimate fallback: face north
        return Quaternion.Euler(0, 0, 0);
    }

    private Quaternion GetRotationFromDirection(Vector2Int direction)
    {
        if (direction == new Vector2Int(0, 1) || direction == new Vector2Int(0, -1)) 
            return Quaternion.Euler(0, 90, 0);   // North/South walls - face east/west
        else 
            return Quaternion.Euler(0, 0, 0);    // East/West walls - face north/south
    }

    private RoomModel FindAdjacentRoom(LevelModel layout, Vector2Int doorPos)
    {
        Vector2Int[] checkDirections = new Vector2Int[]
        {
            new Vector2Int(0, 1), new Vector2Int(0, -1),
            new Vector2Int(1, 0), new Vector2Int(-1, 0)
        };

        foreach (var dir in checkDirections)
        {
            var room = layout.GetRoomAtPosition(doorPos + dir);
            if (room != null) return room;
        }
        
        return null;
    }

    private Quaternion GetDoorRotationFromRoom(RoomModel room, Vector2Int doorPos)
    {
        var bounds = room.Bounds;
        
        if (doorPos.y == bounds.yMax - 1 || doorPos.y == bounds.yMin) 
            return Quaternion.Euler(0, 90, 0);   // North/South wall - face east/west
        else 
            return Quaternion.Euler(0, 0, 0);    // East/West wall - face north/south
    }

    private void CreateProceduralCeiling(LevelModel layout, Transform parent)
    {
        BoundsInt dungeonBounds = layout.OverallBounds;
        
        GameObject ceiling = GameObject.CreatePrimitive(PrimitiveType.Plane);
        ceiling.name = "Ceiling";
        ceiling.transform.SetParent(parent);
        
        Vector3 center = new Vector3(dungeonBounds.center.x, 9f, dungeonBounds.center.y);
        ceiling.transform.position = center;
        
        float scaleX = Mathf.Ceil(dungeonBounds.size.x * 0.1f);
        float scaleZ = Mathf.Ceil(dungeonBounds.size.y * 0.1f);
        ceiling.transform.localScale = new Vector3(scaleX, 1f, scaleZ);
        
        // Apply one-sided mirror material
        Renderer renderer = ceiling.GetComponent<Renderer>();
        renderer.sharedMaterial = CreateOneSidedMirrorMaterial();
        
        // Remove collider - ceiling shouldn't block movement
        GameObject.DestroyImmediate(ceiling.GetComponent<Collider>());
    }

    private Material CreateOneSidedMirrorMaterial()
    {
        Material material = new Material(Shader.Find("Standard"));
        
        #if UNITY_EDITOR
        // Transparent cyan in editor so you can see through it
        material.color = new Color(0, 1, 1, 0.3f);
        material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
        material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
        material.SetInt("_ZWrite", 0);
        material.DisableKeyword("_ALPHATEST_ON");
        material.EnableKeyword("_ALPHABLEND_ON");
        material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
        material.renderQueue = 3000;
        #else
        // Opaque at runtime
        material.color = Color.gray;
        material.SetFloat("_Metallic", 0.1f);
        material.SetFloat("_Glossiness", 0.1f);
        #endif

        return material;
    }

    #endregion
}

// MeshCombiner.cs (renamed from AdvancedMeshCombiner.cs)
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class MeshCombiner
{
    [System.Serializable]
    public class CombinedMeshData
    {
        public string Name;
        public List<CombineInstance> CombineInstances = new List<CombineInstance>();
        public Material Material;
        public int VertexCount => CalculateVertexCount();
        
        private int CalculateVertexCount()
        {
            int total = 0;
            foreach (var instance in CombineInstances)
                if (instance.mesh != null)
                    total += instance.mesh.vertexCount;
            return total;
        }
    }

    private Dictionary<Material, CombinedMeshData> _materialMeshes = new Dictionary<Material, CombinedMeshData>();
    private const int MAX_VERTICES_PER_MESH = 60000;

    public void AddMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale, Material material)
    {
        if (mesh == null || material == null) return;

        if (!_materialMeshes.ContainsKey(material))
        {
            _materialMeshes[material] = new CombinedMeshData
            {
                Name = $"Combined_{material.name}",
                Material = material
            };
        }

        var combineInstance = new CombineInstance
        {
            mesh = mesh,
            transform = Matrix4x4.TRS(position, rotation, scale)
        };

        _materialMeshes[material].CombineInstances.Add(combineInstance);
    }

    public List<GameObject> BuildAllCombinedMeshes(Transform parent)
    {
        List<GameObject> combinedObjects = new List<GameObject>();
        
        foreach (var kvp in _materialMeshes)
        {
            var meshData = kvp.Value;
            if (meshData.CombineInstances.Count == 0) 
                continue;
            if (meshData.VertexCount > MAX_VERTICES_PER_MESH)
            {
                var splitMeshes = BuildSplitMeshes(meshData, parent);
                combinedObjects.AddRange(splitMeshes);
            }
            else
            {
                var combinedObject = BuildSingleCombinedMesh(meshData, parent);
                if (combinedObject != null) combinedObjects.Add(combinedObject);
            }
        }
        _materialMeshes.Clear();
        return combinedObjects;
    }

    private GameObject BuildSingleCombinedMesh(CombinedMeshData meshData, Transform parent)
    {
        try
        {
            GameObject combinedObject = new GameObject(meshData.Name);
            combinedObject.transform.SetParent(parent);

            MeshFilter meshFilter = combinedObject.AddComponent<MeshFilter>();
            MeshRenderer meshRenderer = combinedObject.AddComponent<MeshRenderer>();

            Mesh combinedMesh = new Mesh();
            combinedMesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
            combinedMesh.CombineMeshes(meshData.CombineInstances.ToArray());
            
            meshFilter.mesh = combinedMesh;
            meshRenderer.sharedMaterial = meshData.Material;
            
            var meshCollider = combinedObject.AddComponent<MeshCollider>();
            meshCollider.sharedMesh = combinedMesh;

            Debug.Log($"Created combined mesh: {meshData.Name} with {meshData.CombineInstances.Count} instances, {combinedMesh.vertexCount} vertices");
            return combinedObject;
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Failed to create combined mesh {meshData.Name}: {e.Message}");
            return null;
        }
    }

    private List<GameObject> BuildSplitMeshes(CombinedMeshData meshData, Transform parent, int maxInstancesPerChunk = 2000)
    {
        List<GameObject> chunks = new List<GameObject>();
        int instanceCount = meshData.CombineInstances.Count;
        int chunkCount = Mathf.CeilToInt((float)instanceCount / maxInstancesPerChunk);

        for (int i = 0; i < chunkCount; i++)
        {
            int startIndex = i * maxInstancesPerChunk;
            int count = Mathf.Min(maxInstancesPerChunk, instanceCount - startIndex);
            
            var chunkData = new CombinedMeshData
            {
                Name = $"{meshData.Name}_Chunk{i+1}",
                Material = meshData.Material
            };
            
            chunkData.CombineInstances.AddRange(meshData.CombineInstances.GetRange(startIndex, count));
            
            var chunkObject = BuildSingleCombinedMesh(chunkData, parent);
            if (chunkObject != null) chunks.Add(chunkObject);
        }

        Debug.Log($"Split {meshData.Name} into {chunks.Count} chunks");
        return chunks;
    }

    public void FinalizeRendering(Transform parent)
    {
        BuildAllCombinedMeshes(parent);
    }
}

// PropRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Renders functional props: Entrance/Exit portals, Shop structures, Treasure pedestals, etc.
/// Throws errors for missing assets - no fallbacks.
/// </summary>
public class PropRenderer
{
    private BiomeManager _biomeManager;

    public PropRenderer(BiomeManager biomeManager)
    {
        _biomeManager = biomeManager;
    }

    /// <summary>
    /// Renders all props for the level based on room types and prop models.
    /// </summary>
    public void RenderAllProps(LevelModel layout, List<RoomModel> rooms, BiomeModel biome, Transform parent)
    {
        if (layout == null) throw new System.ArgumentNullException(nameof(layout));
        if (rooms == null) throw new System.ArgumentNullException(nameof(rooms));
        if (biome == null) throw new System.ArgumentNullException(nameof(biome));
        if (parent == null) throw new System.ArgumentNullException(nameof(parent));

        Debug.Log($"Starting prop rendering for biome: {biome.Name}");

        int propsCreated = 0;

        // Render room-specific props (entrance, exit, shop, treasure, boss)
        foreach (var room in rooms)
        {
            if (room != null && IsSpecialRoomType(room.Type))
            {
                if (RenderRoomProp(room, biome, parent))
                {
                    propsCreated++;
                }
            }
        }

        // Render additional props from layout or future PropModel system
        if (layout.AdditionalProps != null)
        {
            foreach (var propData in layout.AdditionalProps)
            {
                if (RenderPropFromData(propData, biome, parent))
                {
                    propsCreated++;
                }
            }
        }

        Debug.Log($"Created {propsCreated} prop instances");
    }

    /// <summary>
    /// Renders a specific room's main prop (entrance, exit, etc.).
    /// </summary>
    public bool RenderRoomProp(RoomModel room, BiomeModel biome, Transform parent)
    {
        if (room == null) throw new System.ArgumentNullException(nameof(room));

        GameObject propPrefab = GetRoomPropPrefab(room.Type, biome);
        if (propPrefab == null)
            throw new System.MissingReferenceException($"Prop prefab not found for room type: {room.Type} in biome: {biome.Name}");

        Vector3 position = CalculatePropPosition(room, propPrefab);
        Quaternion rotation = CalculatePropRotation(room, propPrefab);

        var prop = GameObject.Instantiate(propPrefab, position, rotation, parent);
        prop.name = $"{room.Type}_Prop_{room.ID}";

        // Configure prop components based on type
        ConfigurePropComponents(prop, room.Type);

        Debug.Log($"Created {room.Type} prop at room {room.ID}");
        return true;
    }

    /// <summary>
    /// Renders a prop from prop data (for future PropModel system).
    /// </summary>
    public bool RenderPropFromData(PropData propData, BiomeModel biome, Transform parent)
    {
        if (propData == null) throw new System.ArgumentNullException(nameof(propData));

        GameObject propPrefab = _biomeManager.GetPropPrefab(biome, propData.PropType);
        if (propPrefab == null)
            throw new System.MissingReferenceException($"Prop prefab not found for type: {propData.PropType} in biome: {biome.Name}");

        var prop = GameObject.Instantiate(propPrefab, propData.Position, propData.Rotation, parent);
        prop.name = $"{propData.PropType}_Prop";

        ConfigurePropComponents(prop, propData.PropType);

        return true;
    }

    #region Helper Methods

    private bool IsSpecialRoomType(RoomType roomType)
    {
        return roomType == RoomType.Entrance || roomType == RoomType.Exit || 
               roomType == RoomType.Shop || roomType == RoomType.Treasure || 
               roomType == RoomType.Boss;
    }

    private GameObject GetRoomPropPrefab(RoomType roomType, BiomeModel biome)
    {
        return roomType switch
        {
            RoomType.Entrance => _biomeManager.GetEntrancePropPrefab(biome),
            RoomType.Exit => _biomeManager.GetExitPropPrefab(biome),
            RoomType.Shop => _biomeManager.GetShopPropPrefab(biome),
            RoomType.Treasure => _biomeManager.GetTreasurePropPrefab(biome),
            RoomType.Boss => _biomeManager.GetBossPropPrefab(biome),
            _ => null
        };
    }

    private Vector3 CalculatePropPosition(RoomModel room, GameObject propPrefab)
    {
        // Center the prop in the room, with optional height adjustment
        Vector3 basePosition = new Vector3(room.Center.x, 0f, room.Center.y);
        
        // Adjust height based on prop's bounds if needed
        var renderer = propPrefab.GetComponentInChildren<Renderer>();
        if (renderer != null)
        {
            float heightOffset = renderer.bounds.extents.y;
            basePosition.y += heightOffset;
        }

        return basePosition;
    }

    private Quaternion CalculatePropRotation(RoomModel room, GameObject propPrefab)
    {
        // Default to identity, can be customized per room type or prop type
        // For example, entrance/exit might face toward the room center from door
        return Quaternion.identity;
    }

    private void ConfigurePropComponents(GameObject prop, RoomType roomType)
    {
        // Add specific components based on prop type
        switch (roomType)
        {
            case RoomType.Entrance:
                AddEntranceComponents(prop);
                break;
            case RoomType.Exit:
                AddExitComponents(prop);
                break;
            case RoomType.Shop:
                AddShopComponents(prop);
                break;
            case RoomType.Treasure:
                AddTreasureComponents(prop);
                break;
            case RoomType.Boss:
                AddBossComponents(prop);
                break;
        }
    }

    private void ConfigurePropComponents(GameObject prop, string propType)
    {
        // Configure based on string prop type for future PropModel system
        // Can be expanded based on your prop type definitions
    }

    private void AddEntranceComponents(GameObject prop)
    {
        // Ensure entrance has appropriate components
        if (prop.GetComponent<EntranceController>() == null)
            prop.AddComponent<EntranceController>();
    }

    private void AddExitComponents(GameObject prop)
    {
        // Ensure exit has appropriate components
        if (prop.GetComponent<ExitController>() == null)
            prop.AddComponent<ExitController>();
    }

    private void AddShopComponents(GameObject prop)
    {
        // Ensure shop has appropriate components
        if (prop.GetComponent<ShopController>() == null)
            prop.AddComponent<ShopController>();
    }

    private void AddTreasureComponents(GameObject prop)
    {
        // Ensure treasure has appropriate components
        if (prop.GetComponent<TreasureController>() == null)
            prop.AddComponent<TreasureController>();
    }

    private void AddBossComponents(GameObject prop)
    {
        // Ensure boss room prop has appropriate components
        if (prop.GetComponent<BossRoomController>() == null)
            prop.AddComponent<BossRoomController>();
    }

    #endregion
}

// Temporary data structure for props until PropModel is implemented
[System.Serializable]
public class PropData
{
    public string PropType;
    public Vector3 Position;
    public Quaternion Rotation;
    public Vector3 Scale = Vector3.one;
}