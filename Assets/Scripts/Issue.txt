// -------------------------------------------------- //
// Scripts/Controllers/PlayerController.cs (FIXED)
// -------------------------------------------------- //

using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class PlayerController : MonoBehaviour
{
    [Header("Movement")]
    public float moveSpeed = 5f;
    public float rotationSpeed = 15f;
    
    [Header("Combat")]
    public int maxHealth = 100;
    public int playerDamage = 15;
    public float attackRange = 2f;
    public float attackCooldown = 1f;
    public LayerMask enemyLayer = 1;

    [Header("Components")]
    public Rigidbody rb;
    // public Animator animator;
    public WeaponManager weaponManager;
    public PowerManager powerManager;
    public InventoryManager inventory;
    
    [Header("Visual")]
    public GameObject visualMesh; // Assign the capsule mesh in Inspector
    
    public static PlayerController Instance { get; private set; }
    public int CurrentHealth { get; private set; }
    
    private Vector3 moveDirection;
    private bool isMoving;
    private float lastAttackTime = 0f;
    private bool isDead = false;
    private Camera mainCamera;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            if (transform.parent == null) DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }
    }
    
    void Start()
    {
        CurrentHealth = maxHealth;
        rb = GetComponent<Rigidbody>();
        mainCamera = Camera.main;
        
        // CRITICAL: Hide visual mesh in first-person
        if (visualMesh != null)
        {
            visualMesh.SetActive(false); // Player capsule should not be visible
        }
        
        weaponManager = GetComponent<WeaponManager>();
        if (weaponManager == null)
        {
            weaponManager = gameObject.AddComponent<WeaponManager>();
        }

        powerManager = GetComponent<PowerManager>();
        if (powerManager == null)
        {
            powerManager = gameObject.AddComponent<PowerManager>();
        }
        
        inventory = GetComponent<InventoryManager>();
        if (inventory == null)
        {
            inventory = gameObject.AddComponent<InventoryManager>();
        }
        
        rb.freezeRotation = true;
        rb.constraints = RigidbodyConstraints.FreezeRotation;
        rb.drag = 0f;
        rb.angularDrag = 0f;
        rb.interpolation = RigidbodyInterpolation.Interpolate;
        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
        
        SpawnAtEntrance();
    }
    
    void Update()
    {
        if (isDead) return;
        
        HandleInput();
        HandleCombatInput();
        UpdateAnimations();
        UpdateRoomDetection();
    }
    
    void FixedUpdate()
    {
        if (isDead) return;
        HandleMovement();
    }
    
    private void HandleInput()
    {
        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");
        
        Vector3 inputVector = new(horizontal, 0, vertical);
        moveDirection = GetCameraRelativeMovement(inputVector);
        
        if (moveDirection.magnitude > 1f)
        {
            moveDirection.Normalize();
        }
        
        isMoving = moveDirection.magnitude > 0.1f;
    }
    
    private Vector3 GetCameraRelativeMovement(Vector3 input)
    {
        if (input.magnitude < 0.01f) return Vector3.zero;
        if (mainCamera == null) return input;
        
        Vector3 cameraForward = mainCamera.transform.forward;
        Vector3 cameraRight = mainCamera.transform.right;
        
        cameraForward.y = 0;
        cameraRight.y = 0;
        
        cameraForward.Normalize();
        cameraRight.Normalize();
        
        Vector3 result = (cameraForward * input.z) + (cameraRight * input.x);
        return result;
    }
    
    private void HandleCombatInput()
    {
        if (Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0))
        {
            PerformAttack();
        }
    }
    
    private void HandleMovement()
    {
        if (isMoving && moveDirection.magnitude > 0.01f)
        {
            Vector3 targetVelocity = moveDirection * moveSpeed;
            rb.velocity = new Vector3(targetVelocity.x, rb.velocity.y, targetVelocity.z);
            
            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);
            transform.rotation = Quaternion.Slerp(
                transform.rotation, 
                targetRotation, 
                rotationSpeed * Time.fixedDeltaTime
            );
        }
        else
        {
            rb.velocity = new Vector3(0, rb.velocity.y, 0);
        }
    }
    
    private void PerformAttack()
    {
        if (Time.time < lastAttackTime + attackCooldown)
        {
            Debug.LogError($"Too early to attack, wait {lastAttackTime + attackCooldown - Time.time} more seconds.");
            return;
        }
        Debug.Log("Attacking...");
        
        lastAttackTime = Time.time;
        
        // if (animator != null)
        // {
        //     animator.SetTrigger("Attack");
        // }
        // else
        // {
        //     Debug.LogError($"Animator is null.");
        // }
        
        // CRITICAL FIX: Use camera forward direction for attacks
        Vector3 attackDirection = mainCamera != null ? mainCamera.transform.forward : transform.forward;
        attackDirection.y = 0;
        attackDirection.Normalize();
        
        if (weaponManager != null && weaponManager.currentWeaponData != null)
        {
            Debug.Log("Calling WeaponManager.Attack()...");
            weaponManager.Attack(transform.position + Vector3.up, attackDirection);
        }
        else
        {
            Debug.LogError($"WeaponManager or current weapon data is null.");
            PerformBasicMeleeAttack(attackDirection);
        }
    }
    
    private void PerformBasicMeleeAttack(Vector3 attackDirection)
    {
        Vector3 attackCenter = transform.position + attackDirection * (attackRange * 0.5f);
        
        Collider[] hitEnemies = Physics.OverlapSphere(attackCenter, attackRange, enemyLayer);
        
        foreach (Collider enemy in hitEnemies)
        {
            Vector3 dirToEnemy = (enemy.transform.position - transform.position).normalized;
            float angleToEnemy = Vector3.Angle(attackDirection, dirToEnemy);
            
            if (angleToEnemy < 60f)
            {
                if (enemy.TryGetComponent<EnemyController>(out var enemyController))
                {
                    int finalDamage = playerDamage;
                    if (powerManager != null) finalDamage = powerManager.ModifyDamageDealt(finalDamage);

                    enemyController.TakeDamage(finalDamage);
                    if (powerManager != null) powerManager.OnDamageDealt(finalDamage);
                    
                    Debug.Log($"Hit enemy for {finalDamage} damage!");
                }
            }
        }
    }
    
    private void UpdateAnimations()
    {
        // if (animator != null)
        // {
        //     animator.SetBool("IsMoving", isMoving);
        //     animator.SetFloat("MoveSpeed", moveDirection.magnitude);
        // }
    }
    
    private void UpdateRoomDetection()
    {
        if (Time.frameCount % 30 == 0)
        {
            RoomManager roomManager = FindObjectOfType<RoomManager>();
            if (roomManager != null)
            {
                roomManager.UpdatePlayerRoom(transform.position);
            }
        }
    }
    
    public void TakeDamage(int damage)
    {
        if (isDead) return;
        
        // Apply power damage reduction
        if (powerManager != null)
        {
            damage = powerManager.ModifyDamageTaken(damage);
        }
        
        CurrentHealth -= damage;
        CurrentHealth = Mathf.Max(0, CurrentHealth);
        
        // if (animator != null)
        // {
        //     animator.SetTrigger("TakeDamage");
        // }

        UIManager.Instance?.ShowDamageDisplay(transform.position + Vector3.up, damage, false, false);
        
        Debug.Log($"Player took {damage} damage! Health: {CurrentHealth}/{maxHealth}");
        
        if (CurrentHealth <= 0)
        {
            Die();
        }
    }
    
    public void Heal(int amount)
    {
        if (isDead) return;
        
        CurrentHealth = Mathf.Min(CurrentHealth + amount, maxHealth);
        Debug.Log($"Player healed {amount}! Health: {CurrentHealth}/{maxHealth}");
    }
    
    private void Die()
    {
        if (isDead) return;
        
        isDead = true;
        
        // if (animator != null)
        // {
        //     animator.SetTrigger("Die");
        // }
        
        rb.velocity = Vector3.zero;
        rb.isKinematic = true;
        
        Debug.Log("Player died - Game Over!");
        
        Invoke(nameof(TriggerGameOver), 2f);
    }

    private void TriggerGameOver()
    {
        // Find GameOverUI in scene
        GameOverUI gameOverUI = FindObjectOfType<GameOverUI>();
        if (gameOverUI != null)
        {
            LayoutManager layoutManager = GameDirector.Instance?.layoutManager;
            int floorReached = layoutManager?.LevelConfig?.FloorLevel ?? 1;
            int goldCollected = inventory?.gold ?? 0;
            
            gameOverUI.ShowGameOver(false, floorReached, goldCollected, 0);
        }
        else
        {
            Debug.LogError("PlayerController: GameOverUI not found in scene!");
        }
    }
    
    private void SpawnAtEntrance()
    {
        LayoutManager generator = FindObjectOfType<LayoutManager>();
        if (generator != null && generator.CurrentLayout != null)
        {
            Vector3 spawnPosition = generator.GetEntranceRoomPosition();
            transform.position = spawnPosition;
            
            NavMeshGenerator navMeshGen = generator.GetComponent<NavMeshGenerator>();
            if (navMeshGen != null && navMeshGen.IsPositionOnNavMesh(spawnPosition))
            {
                transform.position = navMeshGen.GetNearestNavMeshPosition(spawnPosition);
            }
            
            Debug.Log($"Player spawned at: {transform.position}");
        }
        else
        {
            Debug.LogWarning("Could not find entrance room for spawn");
        }
    }
    
    // Mobile controls interface
    public void SetMovementInput(Vector2 input)
    {
        Vector3 inputVector = new(input.x, 0, input.y);
        moveDirection = GetCameraRelativeMovement(inputVector);
        
        if (moveDirection.magnitude > 1f)
        {
            moveDirection.Normalize();
        }
        
        isMoving = moveDirection.magnitude > 0.1f;
    }
    
    public void OnAttackButtonPressed()
    {
        PerformAttack();
    }
    
    void OnDrawGizmosSelected()
    {
        if (mainCamera == null) return;
        
        // Draw attack range in camera direction
        Vector3 attackDirection = mainCamera.transform.forward;
        attackDirection.y = 0;
        attackDirection.Normalize();
        
        Gizmos.color = Color.red;
        Vector3 attackCenter = transform.position + attackDirection * (attackRange * 0.5f);
        Gizmos.DrawWireSphere(attackCenter, attackRange);
        
        // Draw camera forward direction
        Gizmos.color = Color.blue;
        Gizmos.DrawRay(transform.position + Vector3.up, attackDirection * 3f);
    }
}

// ================================================== //
// Scripts/Managers/WeaponManager.cs (FIXED)
// ================================================== //

using UnityEngine;

public class WeaponManager : MonoBehaviour
{
    [Header("Current Weapon")]
    public WeaponData currentWeaponData;
    public GameObject currentWeaponInstance;
    
    [Header("Settings")]
    public Transform weaponHolder;
    private float lastAttackTime = 0f;
    
    private PlayerController player;
    private Camera mainCamera;
    
    void Start()
    {
        player = GetComponent<PlayerController>();
        mainCamera = Camera.main;
        
        // CRITICAL FIX: Create weapon holder in front of camera view
        if (weaponHolder == null)
        {
            GameObject holder = new("WeaponHolder");
            holder.transform.SetParent(transform);
            // Position weapon in front and slightly to the right (FPS view)
            holder.transform.SetLocalPositionAndRotation(new Vector3(0.8f, 0f, 0.6f), Quaternion.identity);
            weaponHolder = holder.transform;
        }
        
        // Start with default weapon
        WeaponData starterWeapon = WeaponConfig.Instance?.GetWeaponData("Sword");
        if (starterWeapon != null)
        {
            EquipWeapon(starterWeapon);
        }
    }
    
    void LateUpdate()
    {
        // CRITICAL: Make weapon holder face camera direction
        if (weaponHolder != null && mainCamera != null)
        {
            weaponHolder.rotation = mainCamera.transform.rotation;
        }
    }
    
    public void PickupWeapon(WeaponData weaponData)
    {
        EquipWeapon(weaponData);
    }
    
    private void EquipWeapon(WeaponData weaponData)
    {
        // Destroy old weapon visual
        if (currentWeaponInstance != null)
        {
            Destroy(currentWeaponInstance);
        }
        
        currentWeaponData = weaponData;
        
        // Create visual if prefab exists
        if (weaponData.prefab != null)
        {
            currentWeaponInstance = Instantiate(weaponData.prefab, weaponHolder);
            currentWeaponInstance.transform.localPosition = Vector3.zero;
            currentWeaponInstance.transform.localRotation = Quaternion.identity;
            
            // Setup weapon script if it has one
            WeaponModel weaponScript = currentWeaponInstance.GetComponent<WeaponModel>();
            if (weaponScript != null)
            {
                weaponScript.baseDamage = weaponData.damage;
                weaponScript.attackRange = weaponData.range;
                weaponScript.attackCooldown = weaponData.attackSpeed;
                weaponScript.Equip();
            }
        }
        
        // Update player stats
        if (player != null)
        {
            player.playerDamage = weaponData.damage;
            player.attackCooldown = weaponData.attackSpeed;
            player.attackRange = weaponData.range;
        }
        
        Debug.Log($"Equipped: {weaponData.weaponName} (Damage: {weaponData.damage}, Speed: {weaponData.attackSpeed})");
    }
    
    public void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (currentWeaponData == null)
        {
            Debug.LogError("Current weapon data is null.");
            return;
        }
        if (Time.time < lastAttackTime + currentWeaponData.attackSpeed)
        {
            Debug.LogError($"Too early to attack, wait {lastAttackTime + currentWeaponData.attackSpeed - Time.time} more seconds.");
            return;
        }
        
        lastAttackTime = Time.time;

        // Trigger weapon animation if exists
        if (currentWeaponInstance != null)
        {
            WeaponModel weaponScript = currentWeaponInstance.GetComponent<WeaponModel>();
            Debug.Log($"weaponScript assigned as {weaponScript.GetType()}.");
            if (weaponScript != null)
            {
                Debug.Log($"Calling {weaponScript.GetType()}.Attack()...");
                weaponScript.Attack(attackPosition, attackDirection);
                return; // Let weapon handle its own attack
            }
            else
            {
                Debug.LogError($"WeaponModel is null.");
            }
            
            Animator weaponAnimator = currentWeaponInstance.GetComponentInChildren<Animator>();
            if (weaponAnimator != null)
            {
                weaponAnimator.SetTrigger("Attack");
            }
            else
            {
                Debug.LogError($"Animator is null.");
            }
        }
        
        // Fallback: Handle attack based on weapon type
        switch (currentWeaponData.weaponType)
        {
            case WeaponType.Melee:
            case WeaponType.Charge:
                PerformMeleeAttack(attackPosition, attackDirection);
                break;
                
            case WeaponType.Ranged:
            case WeaponType.Magic:
                PerformRangedAttack(attackPosition, attackDirection);
                break;
        }
    }
    
    private void PerformMeleeAttack(Vector3 position, Vector3 direction)
    {
        Vector3 attackCenter = position + direction * (currentWeaponData.range * 0.5f);
        
        Collider[] hits = Physics.OverlapSphere(attackCenter, currentWeaponData.range, player.enemyLayer);
        
        foreach (Collider hit in hits)
        {
            Vector3 dirToTarget = (hit.transform.position - position).normalized;
            float angleToTarget = Vector3.Angle(direction, dirToTarget);
            
            if (angleToTarget <= 60f)
            {
                DealDamageToEnemy(hit.gameObject);
            }
        }
        
        // Visual effect
        SpawnMeleeEffect(attackCenter);
    }
    
    private void PerformRangedAttack(Vector3 position, Vector3 direction)
    {
        // Check if weapon has projectile prefab
        WeaponModel weaponScript = currentWeaponInstance?.GetComponent<WeaponModel>();
        GameObject projectilePrefab = null;
        
        if (weaponScript is RangedWeaponModel ranged)
        {
            projectilePrefab = ranged.projectilePrefab;
        }
        else if (weaponScript is MagicWeaponModel magic)
        {
            projectilePrefab = magic.spellPrefabs != null && magic.spellPrefabs.Length > 0 
                ? magic.spellPrefabs[magic.currentSpellType] 
                : null;
        }
        
        GameObject projectile;
        
        if (projectilePrefab != null)
        {
            // Use weapon's projectile
            projectile = Instantiate(projectilePrefab, position, Quaternion.LookRotation(direction));
        }
        else
        {
            // Create fallback projectile
            projectile = CreateFallbackProjectile(position, direction);
        }
        
        // Setup projectile physics
        Rigidbody rb = projectile.GetComponent<Rigidbody>();
        if (rb == null)
        {
            rb = projectile.AddComponent<Rigidbody>();
            rb.useGravity = false;
            rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
        }
        rb.velocity = direction * currentWeaponData.projectileSpeed;
        
        // Setup projectile damage
        ProjectileController projController = projectile.GetComponent<ProjectileController>();
        if (projController == null)
        {
            projController = projectile.AddComponent<ProjectileController>();
        }
        projController.damage = currentWeaponData.damage;
        projController.owner = player.gameObject;
        projController.targetLayer = player.enemyLayer;
        
        // Auto-destroy
        Destroy(projectile, 5f);
    }
    
    private GameObject CreateFallbackProjectile(Vector3 position, Vector3 direction)
    {
        GameObject projectile = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        projectile.transform.position = position;
        projectile.transform.localScale = Vector3.one * 0.3f;
        projectile.name = "Projectile";
        
        // Visual
        Renderer renderer = projectile.GetComponent<Renderer>();
        Color projectileColor = currentWeaponData.weaponType == WeaponType.Magic ? Color.magenta : Color.yellow;
        Material mat = new(Shader.Find("Standard"))
        {
            color = projectileColor
        };
        mat.EnableKeyword("_EMISSION");
        mat.SetColor("_EmissionColor", projectileColor * 2f);
        renderer.material = mat;
        
        return projectile;
    }
    
    private void SpawnMeleeEffect(Vector3 position)
    {
        GameObject effect = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        effect.transform.position = position;
        effect.transform.localScale = Vector3.one * 0.5f;
        
        Renderer renderer = effect.GetComponent<Renderer>();
        Material mat = new(Shader.Find("Standard"))
        {
            color = new Color(1f, 1f, 1f, 0.5f)
        };
        renderer.material = mat;
        
        Destroy(effect.GetComponent<Collider>());
        Destroy(effect, 0.2f);
    }
    
    private void DealDamageToEnemy(GameObject enemy)
    {
        if (enemy.TryGetComponent<EnemyController>(out var enemyController))
        {
            int finalDamage = currentWeaponData.damage;
            
            // Apply power modifiers
            if (player.powerManager != null)
            {
                finalDamage = player.powerManager.ModifyDamageDealt(finalDamage);
            }
            
            enemyController.TakeDamage(finalDamage);
            
            // Trigger effects
            if (player.powerManager != null)
            {
                player.powerManager.OnDamageDealt(finalDamage);
            }
            
            // Show damage number
            UIManager.Instance?.ShowDamageDisplay(enemy.transform.position + Vector3.up, finalDamage, false, false);
        }
    }
}

// ================================================== //
// Scripts/Models/WeaponModel.cs (UPDATED)
// ================================================== //

using UnityEngine;

/// <summary>
/// Base weapon class with animator integration
/// </summary>
public abstract class WeaponModel : MonoBehaviour
{
    [Header("Weapon Stats")]
    public string weaponName = "Weapon";
    public int baseDamage = 10;
    public float attackCooldown = 1f;
    public float attackRange = 2f;
    public LayerMask targetLayer;
    
    [Header("Animation")]
    public Animator animator;
    public RuntimeAnimatorController animatorController;
    
    protected float lastAttackTime = 0f;
    protected bool isEquipped = false;
    protected bool isAttacking = false;

    // public bool CanAttack => Time.time >= lastAttackTime + attackCooldown && !isAttacking;
    public bool CanAttack()
    {
        Debug.Log($"Time: {Time.time}");
        Debug.Log($"Cooldown: {lastAttackTime + attackCooldown}");
        Debug.Log($"Able to attack: {Time.time >= lastAttackTime + attackCooldown}");
        Debug.Log($"Is attacking: {isAttacking}");
        return Time.time >= lastAttackTime + attackCooldown && !isAttacking;
    }

    public virtual void Equip()
    {
        isEquipped = true;
        gameObject.SetActive(true);
        
        if (animator == null)
        {
            animator = GetComponentInChildren<Animator>();
        }
    }
    
    public virtual void Unequip()
    {
        isEquipped = false;
        gameObject.SetActive(false);
    }
    
    public abstract void Attack(Vector3 attackPosition, Vector3 attackDirection);
    
    protected void RegisterAttack()
    {
        Debug.Log($"Attack registered on {lastAttackTime}");
        lastAttackTime = Time.time;
    }
}











// ================================================== //
// WEAPON DATA - Configuration
// ================================================== //

[System.Serializable]
public class WeaponData
{
    public string weaponName;
    public WeaponType weaponType;
    public string description;
    
    [Header("Stats")]
    public int damage;
    public float attackSpeed;
    public float range;
    public float projectileSpeed;
    public int manaCost;
    
    [Header("Prefab")]
    public GameObject prefab;
    
    [Header("Animation")]
    public RuntimeAnimatorController animatorController;
}

public enum WeaponType
{
    Melee,      // Sword - combo system
    Charge,     // Axe - hold to charge
    Ranged,     // Bow - draw and release
    Magic,      // Staff - spell types
    Rapid       // Daggers - fast attacks
}

// ================================================== //
// MELEE WEAPON - Combo System
// ================================================== //

using UnityEngine;

public class MeleeWeaponModel : WeaponModel
{
    [Header("Melee Settings")]
    public float swingAngle = 60f;
    public GameObject slashEffectPrefab;
    
    [Header("Combo System")]
    public int maxCombo = 3;
    public int currentCombo = 0;
    private float lastComboTime = 0f;
    private float comboWindow = 0.5f;
    private bool comboQueued = false;
    
    void Update()
    {
        // Reset combo if window expired
        if (Time.time > lastComboTime + comboWindow && currentCombo > 0)
        {
            ResetCombo();
        }
        
        // Process queued combo
        if (comboQueued && !isAttacking && CanAttack())
        {
            comboQueued = false;
            ContinueCombo();
        }
    }
    
    public override void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (!CanAttack())
        {
            Debug.LogError("Cannot attack.");
            // Queue next combo attack if within window
            if (isAttacking && Time.time <= lastComboTime + comboWindow)
            {
            Debug.Log("Attack is queued into combo.");
                comboQueued = true;
            }
            else
            {
                Debug.LogError("Cannot queue into combo either.");
            }
            return;
        }
        
        if (currentCombo == 0)
        {
            Debug.Log("Combo index is 0. Starting combo...");
            StartCombo();
        }
    }
    
    private void StartCombo()
    {
        currentCombo = 1;
        lastComboTime = Time.time;
        // isAttacking = true;
        
        if (animator != null)
        {
            animator.SetInteger("ComboIndex", currentCombo);
            animator.SetTrigger("Attack");
        }
        else
        {
            Debug.LogError("Animator is null.");
        }
        
        Debug.Log("Registering attack...");
        RegisterAttack();
    }
    
    private void ContinueCombo()
    {
        currentCombo++;
        if (currentCombo > maxCombo)
        {
            currentCombo = 1; // Loop back
        }
        
        lastComboTime = Time.time;
        // isAttacking = true;
        
        if (animator != null)
        {
            animator.SetInteger("ComboIndex", currentCombo);
            animator.SetTrigger("Attack");
        }
        
        RegisterAttack();
    }
    
    private void ResetCombo()
    {
        currentCombo = 0;
        comboQueued = false;
        
        if (animator != null)
        {
            animator.SetInteger("ComboIndex", 0);
        }
    }
    
    // Called by animation event
    public void OnDealDamage()
    {
        // Damage detection in cone
        Vector3 attackCenter = transform.position + transform.forward * (attackRange * 0.5f);
        Collider[] hits = Physics.OverlapSphere(attackCenter, attackRange, targetLayer);
        
        foreach (Collider hit in hits)
        {
            Vector3 dirToTarget = (hit.transform.position - transform.position).normalized;
            float angleToTarget = Vector3.Angle(transform.forward, dirToTarget);
            
            if (angleToTarget <= swingAngle / 2f)
            {
                DamageTarget(hit.gameObject);
            }
        }
    }
    
    // Called by animation event
    public void OnAttackComplete()
    {
        isAttacking = false;
    }
    
    protected virtual void DamageTarget(GameObject target)
    {
        if (target.TryGetComponent<EnemyController>(out var enemy))
        {
            enemy.TakeDamage(baseDamage);
            Debug.Log($"{weaponName} hit {target.name} for {baseDamage} damage");
        }
    }
}

// ================================================== //
// CHARGE WEAPON - Hold to charge
// ================================================== //

using UnityEngine;

public class HeavyWeaponModel : WeaponModel
{
    [Header("Charge Settings")]
    public float maxChargeTime = 2f;
    public float chargeMultiplier = 2f;
    
    private bool isCharging = false;
    private float chargeStartTime = 0f;
    private float currentCharge = 0f;
    
    void Update()
    {
        if (isCharging)
        {
            float chargeTime = Time.time - chargeStartTime;
            currentCharge = Mathf.Clamp01(chargeTime / maxChargeTime);
            
            if (animator != null)
            {
                animator.SetFloat("ChargeLevel", currentCharge);
            }
        }
    }
    
    public override void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (!CanAttack()) return;
        
        // Start charging
        isCharging = true;
        chargeStartTime = Time.time;
        
        if (animator != null)
        {
            animator.SetBool("IsCharging", true);
            animator.SetTrigger("Attack");
        }
    }
    
    public void ReleaseAttack()
    {
        if (!isCharging) return;
        
        isCharging = false;
        
        if (animator != null)
        {
            animator.SetBool("IsCharging", false);
        }
        
        RegisterAttack();
    }
    
    // Called by animation event
    public void OnDealDamage()
    {
        int finalDamage = Mathf.RoundToInt(baseDamage * (1f + currentCharge * chargeMultiplier));
        
        Vector3 attackCenter = transform.position + transform.forward * (attackRange * 0.5f);
        Collider[] hits = Physics.OverlapSphere(attackCenter, attackRange, targetLayer);
        
        foreach (Collider hit in hits)
        {
            if (hit.TryGetComponent<EnemyController>(out var enemy))
            {
                enemy.TakeDamage(finalDamage);
                
                // Knockback on charged attacks
                if (currentCharge > 0.5f && hit.TryGetComponent<Rigidbody>(out var rb))
                {
                    Vector3 knockback = (hit.transform.position - transform.position).normalized * 10f;
                    rb.AddForce(knockback, ForceMode.Impulse);
                }
            }
        }
        
        currentCharge = 0f;
    }
    
    // Called by animation event
    public void OnAttackComplete()
    {
        isAttacking = false;
    }
}

// ================================================== //
// RANGED WEAPON - Draw and release
// ================================================== //

using UnityEngine;

public class RangedWeaponModel : WeaponModel
{
    [Header("Ranged Settings")]
    public GameObject projectilePrefab;
    public float projectileSpeed = 20f;
    public Transform firePoint;
    
    private bool isDrawing = false;
    private float drawStartTime = 0f;
    private float drawAmount = 0f;
    private float drawTime = 0.5f;
    
    void Update()
    {
        if (isDrawing)
        {
            drawAmount += Time.deltaTime * 2f; // 0.5s to full draw
            
            if (animator != null)
            {
                animator.SetFloat("DrawAmount", drawAmount);
            }
        }
    }
    
    public override void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (!CanAttack()) return;
        
        // Start drawing
        isDrawing = true;
        drawStartTime = Time.time;
        
        if (animator != null)
        {
            animator.SetBool("IsDrawing", true);
            animator.SetTrigger("Attack");
        }
    }
    
    public void ReleaseAttack()
    {
        if (!isDrawing) return;
        
        isDrawing = false;
        
        if (animator != null)
        {
            animator.SetBool("IsDrawing", false);
        }
        
        RegisterAttack();
    }
    
    // Called by animation event
    public void OnSpawnProjectile()
    {
        if (projectilePrefab == null) return;
        
        Vector3 spawnPos = firePoint != null ? firePoint.position : transform.position;
        GameObject projectile = Instantiate(projectilePrefab, spawnPos, Quaternion.LookRotation(transform.forward));
        
        if (projectile.TryGetComponent<Rigidbody>(out var rb))
        {
            rb.velocity = transform.forward * projectileSpeed * (0.5f + drawAmount * 0.5f);
        }
        
        if (projectile.TryGetComponent<ProjectileModel>(out var proj))
        {
            proj.damage = Mathf.RoundToInt(baseDamage * (0.5f + drawAmount * 0.5f));
            proj.targetLayer = targetLayer;
        }
        
        Destroy(projectile, 5f);
        drawAmount = 0f;
    }
    
    // Called by animation event
    public void OnAttackComplete()
    {
        isAttacking = false;
    }
}

// ================================================== //
// MAGIC WEAPON - Spell types
// ================================================== //

using UnityEngine;

public class MagicWeaponModel : WeaponModel
{
    [Header("Magic Settings")]
    public GameObject[] spellPrefabs; // 0:Fireball, 1:Lightning, 2:Ice
    public float projectileSpeed = 15f;
    public Transform firePoint;
    public int currentSpellType = 0;
    
    public override void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (!CanAttack()) return;
        
        isAttacking = true;
        
        if (animator != null)
        {
            animator.SetInteger("SpellType", currentSpellType);
            animator.SetTrigger("Attack");
        }
        
        RegisterAttack();
    }
    
    public void SetSpellType(int spellType)
    {
        currentSpellType = Mathf.Clamp(spellType, 0, spellPrefabs.Length - 1);
    }
    
    // Called by animation event
    public void OnSpawnProjectile()
    {
        if (spellPrefabs[currentSpellType] == null) return;
        
        Vector3 spawnPos = firePoint != null ? firePoint.position : transform.position;
        GameObject spell = Instantiate(spellPrefabs[currentSpellType], spawnPos, Quaternion.LookRotation(transform.forward));
        
        if (spell.TryGetComponent<Rigidbody>(out var rb))
        {
            rb.velocity = transform.forward * projectileSpeed;
        }
        
        if (spell.TryGetComponent<ProjectileModel>(out var proj))
        {
            proj.damage = baseDamage;
            proj.targetLayer = targetLayer;
        }
        
        Destroy(spell, 5f);
    }
    
    // Called by animation event
    public void OnAttackComplete()
    {
        isAttacking = false;
    }
}

// ================================================== //
// RAPID WEAPON - Fast alternating attacks
// ================================================== //

using UnityEngine;

public class LightWeaponModel : WeaponModel
{
    [Header("Rapid Settings")]
    public float attackSpeedMultiplier = 1.5f;
    
    private int attackCount = 0;
    private int finisherThreshold = 3;
    
    public override void Attack(Vector3 attackPosition, Vector3 attackDirection)
    {
        if (!CanAttack()) return;
        
        isAttacking = true;
        attackCount++;
        
        if (animator != null)
        {
            animator.SetInteger("AttackCount", attackCount % 2); // Alternate 0/1
            animator.SetTrigger("Attack");
            
            // Speed up animation
            animator.speed = attackSpeedMultiplier;
        }
        
        RegisterAttack();
        
        // Reset count after finisher
        if (attackCount >= finisherThreshold)
        {
            attackCount = 0;
        }
    }
    
    // Called by animation event
    public void OnDealDamage()
    {
        Vector3 attackCenter = transform.position + transform.forward * (attackRange * 0.5f);
        Collider[] hits = Physics.OverlapSphere(attackCenter, attackRange, targetLayer);
        
        foreach (Collider hit in hits)
        {
            if (hit.TryGetComponent<EnemyController>(out var enemy))
            {
                enemy.TakeDamage(baseDamage);
            }
        }
    }
    
    // Called by animation event
    public void OnAttackComplete()
    {
        isAttacking = false;
    }
}