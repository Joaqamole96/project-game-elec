// -------------------- //
// Scripts/Generators/CorridorGenerator.cs
// -------------------- //

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CorridorGenerator
{
    public List<CorridorModel> GenerateTotalCorridors(List<PartitionModel> partitions, System.Random random)
    {
        var totalCorrs = new List<CorridorModel>();
        // Confusing; why use partitions for pairing instead of rooms?
        var totalFloors = GetFloorTiles(partitions);
        var roomPairs = new HashSet<(int, int)>();
        
        foreach (var part in partitions)
        {
            if (part.Neighbors == null) continue;
            
            foreach (var neighbor in part.Neighbors)
            {
                // NOTE: If part.Neighbors wasn't null then for sure each neighbor in Neighbors isn't null.
                // Keep it just in case, but remove in the future once sure.
                if (neighbor == null) continue;
                if (part.Room == null || neighbor.Room == null) continue;
                
                var roomA = part.Room;
                var roomB = neighbor.Room;
                var roomPairKey = (Mathf.Min(roomA.ID, roomB.ID), Mathf.Max(roomA.ID, roomB.ID));
                
                if (roomPairs.Contains(roomPairKey)) continue;
                
                var corridor = GenerateCorridor(roomA, roomB, totalFloors, random);
                if (corridor != null)
                {
                    totalCorrs.Add(corridor);
                    roomPairs.Add(roomPairKey);
                }
            }
        }
        
        Debug.Log($"CorridorGenerator.GenerateTotalCorridors(): Generated all total corridors.");
        return totalCorrs;
    }

    private HashSet<Vector2Int> GetFloorTiles(List<PartitionModel> partitions)
    {
        var totalFloors = new HashSet<Vector2Int>();

        foreach (var part in partitions)
            if (part.Room != null)
                foreach (var floorPos in GetFloorTile(part.Room))
                    totalFloors.Add(floorPos);
        
        Debug.Log($"CorridorGenerator.GetFloorTiles(): Collected all total floors.");
        return totalFloors;
    }

    private IEnumerable<Vector2Int> GetFloorTile(RoomModel room)
    {
        for (int x = room.Bounds.xMin + 1; x < room.Bounds.xMax - 1; x++)
            for (int y = room.Bounds.yMin + 1; y < room.Bounds.yMax - 1; y++)
                yield return new Vector2Int(x, y);
    }

    private CorridorModel GenerateCorridor(RoomModel roomA, RoomModel roomB, HashSet<Vector2Int> totalFloors, System.Random random)
    {
        if (roomA == null || roomB == null) return null;
        
        var (doorA, doorB) = FindDoorAlignment(roomA, roomB, random);
        if (doorA == null || doorB == null)
        {
            doorA = FindClosestWall(roomA, roomB.Center);
            doorB = FindClosestWall(roomB, roomA.Center);
        }
        
        if (doorA == null) doorA = FindAnyValidWall(roomA);
        if (doorB == null) doorB = FindAnyValidWall(roomB);
        
        if (doorA == null || doorB == null)
        {
            Debug.LogWarning($"Failed to find door positions between rooms {roomA.ID} and {roomB.ID}");
            return null;
        }

        var corrTiles = CreateLShapedCorridor(doorA.Value, doorB.Value, totalFloors);
        if (corrTiles.Count == 0)
        {
            Debug.LogWarning($"Failed to create corridor between rooms {roomA.ID} and {roomB.ID}");
            return null;
        }

        return new CorridorModel(corrTiles, roomA, roomB, new DoorModel(doorA.Value), new DoorModel(doorB.Value));
    }

    private (Vector2Int?, Vector2Int?) FindDoorAlignment(RoomModel roomA, RoomModel roomB, System.Random random)
    {
        if (roomA?.Bounds == null || roomB?.Bounds == null) return (null, null);
        
        var boundsA = roomA.Bounds;
        var boundsB = roomB.Bounds;

        if (boundsA.yMax <= boundsB.yMin || boundsB.yMax <= boundsA.yMin)
        {
            int overlapStart = Mathf.Max(boundsA.xMin, boundsB.xMin);
            int overlapEnd = Mathf.Min(boundsA.xMax, boundsB.xMax);
            if (overlapStart < overlapEnd - 2)
            {
                int doorX = random.Next(overlapStart + 1, overlapEnd - 1);
                bool roomAIsAbove = boundsA.yMax <= boundsB.yMin;
                Vector2Int doorA = roomAIsAbove ? new(doorX, boundsA.yMax - 1) : new(doorX, boundsA.yMin);
                Vector2Int doorB = roomAIsAbove ? new(doorX, boundsB.yMin) : new(doorX, boundsB.yMax - 1);
                return (doorA, doorB);
            }
        }

        if (boundsA.xMax <= boundsB.xMin || boundsB.xMax <= boundsA.xMin)
        {
            int overlapStart = Mathf.Max(boundsA.yMin, boundsB.yMin);
            int overlapEnd = Mathf.Min(boundsA.yMax, boundsB.yMax);
            if (overlapStart < overlapEnd - 2)
            {
                int doorY = random.Next(overlapStart + 1, overlapEnd - 1);
                bool roomAIsLeft = boundsA.xMax <= boundsB.xMin;
                Vector2Int doorA = roomAIsLeft ? new(boundsA.xMax - 1, doorY) : new(boundsA.xMin, doorY);
                Vector2Int doorB = roomAIsLeft ? new(boundsB.xMin, doorY) : new(boundsB.xMax - 1, doorY);
                return (doorA, doorB);
            }
        }

        return (null, null);
    }

    private Vector2Int? FindClosestWall(RoomModel room, Vector2Int target)
    {
        if (room?.Bounds == null) return null;
        
        var candidates = new List<Vector2Int>();
        var bounds = room.Bounds;

        for (int x = bounds.xMin + 1; x < bounds.xMax - 1; x++)
        {
            candidates.Add(new Vector2Int(x, bounds.yMax - 1));
            candidates.Add(new Vector2Int(x, bounds.yMin));
        }
        for (int y = bounds.yMin + 1; y < bounds.yMax - 1; y++)
        {
            candidates.Add(new Vector2Int(bounds.xMax - 1, y));
            candidates.Add(new Vector2Int(bounds.xMin, y));
        }

        return candidates.OrderBy(pos => Vector2Int.Distance(pos, target)).FirstOrDefault();
    }

    private Vector2Int? FindAnyValidWall(RoomModel room)
    {
        if (room?.Bounds == null) return null;
        
        var bounds = room.Bounds;
        if (bounds.width >= 3 && bounds.height >= 3)
            return new Vector2Int(bounds.xMin + 1, bounds.yMin + 1);
        
        return null;
    }

    private List<Vector2Int> CreateLShapedCorridor(Vector2Int start, Vector2Int end, HashSet<Vector2Int> totalFloors)
    {
        var tiles = new List<Vector2Int>();
        int dx = Mathf.Clamp(end.x - start.x, -1, 1);
        
        for (int x = start.x; x != end.x; x += dx)
        {
            var pos = new Vector2Int(x, start.y);
            if (!totalFloors.Contains(pos))
                tiles.Add(pos);
        }

        int dy = Mathf.Clamp(end.y - start.y, -1, 1);
        for (int y = start.y; y != end.y; y += dy)
        {
            var pos = new Vector2Int(end.x, y);
            if (!totalFloors.Contains(pos))
                tiles.Add(pos);
        }

        tiles.Add(end);
        return tiles;
    }
}

// -------------------- //
// Scripts/Generators/LayoutGenerator.cs
// -------------------- //

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

// WARNING!: This class was derived from legacy code. I tried my best to
// resolve the list of problems, but some require more thorough debugging

public class LayoutGenerator
{
    public void BuildFinalGeometry(LevelModel level)
    {
        ClearLayoutData(level);
        BuildFloorGeometry(level);
        BuildWallGeometry(level);
        
        Debug.Log($"Geometry built: {level.Rooms.Count} rooms, {level.AllFloorTiles.Count} floor tiles");
    }
    
    private void ClearLayoutData(LevelModel level)
    {
        level.AllFloorTiles.Clear();
        level.AllWallTiles.Clear();
        level.AllDoorTiles.Clear();
    }

    private void BuildFloorGeometry(LevelModel level)
    {
        var allFloorTiles = new HashSet<Vector2Int>();
        int roomsProcessed = 0;
        int corridorTilesProcessed = 0;

        // Process room floors
        foreach (var room in level.Rooms.Where(room => room != null))
        {
            try 
            {
                // The RoomModel class, and as a whole all Model classes, no longer has any logic.
                var roomFloors = room.GetFloorTiles();
                int roomFloorCount = AddRoomFloorsToSet(roomFloors, allFloorTiles);
                roomsProcessed++;
                
                Debug.Log($"Room {room.ID} ({room.Type}): added {roomFloorCount} floor tiles");
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Error processing room {room?.ID}: {ex.Message}");
            }
        }

        // Process corridor floors
        corridorTilesProcessed = AddCorridorFloorsToSet(level.Corridors, allFloorTiles);

        level.AllFloorTiles = allFloorTiles;
    }

    private int AddRoomFloorsToSet(IEnumerable<Vector2Int> roomFloors, HashSet<Vector2Int> floorSet)
    {
        int count = 0;
        foreach (var floorPos in roomFloors)
        {
            floorSet.Add(floorPos);
            count++;
        }
        return count;
    }

    private int AddCorridorFloorsToSet(List<CorridorModel> corridors, HashSet<Vector2Int> floorSet)
    {
        int count = 0;
        foreach (var corridor in corridors.Where(c => c?.Tiles != null))
        {
            foreach (var tile in corridor.Tiles)
            {
                floorSet.Add(tile);
                count++;
            }
        }
        return count;
    }
    
    private void BuildWallGeometry(LevelModel level)
    {
        BuildWallsWithTypes(level);
    }

    private void BuildWallsWithTypes(LevelModel level)
    {
        var allWalls = new HashSet<Vector2Int>();

        // Build walls in stages
        var roomWallPerimeters = BuildRoomWalls(level, allWalls);
        BuildCorridorWalls(level, allWalls, roomWallPerimeters);
        ProcessDoors(level, allWalls, roomWallPerimeters);

        level.AllWallTiles = allWalls;
    }

    private Dictionary<RoomModel, HashSet<Vector2Int>> BuildRoomWalls(LevelModel level, HashSet<Vector2Int> allWalls)
    {
        var roomWallPerimeters = new Dictionary<RoomModel, HashSet<Vector2Int>>();
        
        foreach (var room in level.Rooms.Where(room => room != null))
        {
            // Again, Model classes have no logic.
            var wallPerimeter = new HashSet<Vector2Int>(room.GetWallPerimeter());
            roomWallPerimeters[room] = wallPerimeter;
            allWalls.UnionWith(wallPerimeter);
        }

        return roomWallPerimeters;
    }

    private void BuildCorridorWalls(LevelModel level, HashSet<Vector2Int> allWalls, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        foreach (var corridor in level.Corridors.Where(c => c?.Tiles != null))
        {
            foreach (var corridorTile in corridor.Tiles)
            {
                AddWallsAroundCorridorTile(corridorTile, level.AllFloorTiles, allWalls, roomWallPerimeters, level.Rooms);
            }
        }
    }

    private void AddWallsAroundCorridorTile(Vector2Int corridorTile, HashSet<Vector2Int> floorTiles, HashSet<Vector2Int> allWalls, 
                                          Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters, List<RoomModel> rooms)
    {
        foreach (var neighbor in GetCardinalNeighbors(corridorTile))
        {
            // Add wall if position is not a floor tile and not already a wall
            if (!floorTiles.Contains(neighbor) && !allWalls.Contains(neighbor))
            {
                allWalls.Add(neighbor);
                AddToRoomWallPerimeter(neighbor, rooms, roomWallPerimeters);
            }
        }
    }

    private void AddToRoomWallPerimeter(Vector2Int wallPosition, List<RoomModel> rooms, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        var room = GetRoomAtPosition(wallPosition, rooms);
        if (room != null && roomWallPerimeters.ContainsKey(room))
        {
            roomWallPerimeters[room].Add(wallPosition);
        }
    }

    private void ProcessDoors(LevelModel level, HashSet<Vector2Int> allWalls, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        RemoveDoorPositionsFromWalls(level, allWalls, roomWallPerimeters);
    }

    private void RemoveDoorPositionsFromWalls(LevelModel level, HashSet<Vector2Int> allWalls, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        foreach (var corridor in level.Corridors.Where(IsValidCorridor))
        {
            RemoveDoorPosition(corridor.StartDoor.Position, corridor.StartRoom, allWalls, roomWallPerimeters, level);
            RemoveDoorPosition(corridor.EndDoor.Position, corridor.EndRoom, allWalls, roomWallPerimeters, level);
        }
    }

    private bool IsValidCorridor(CorridorModel corridor)
    {
        return corridor?.StartRoom != null && corridor?.EndRoom != null;
    }

    private void RemoveDoorPosition(Vector2Int doorPosition, RoomModel room, HashSet<Vector2Int> allWalls, 
                                  Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters, LevelModel level)
    {
        if (roomWallPerimeters.ContainsKey(room))
        {
            roomWallPerimeters[room].Remove(doorPosition);
        }
        
        allWalls.Remove(doorPosition);
        level.AllDoorTiles.Add(doorPosition);
    }

    private List<Vector2Int> GetCardinalNeighbors(Vector2Int pos)
    {
        return new List<Vector2Int>
        {
            new Vector2Int(pos.x + 1, pos.y),     // Right
            new Vector2Int(pos.x - 1, pos.y),     // Left
            new Vector2Int(pos.x, pos.y + 1),     // Up
            new Vector2Int(pos.x, pos.y - 1)      // Down
        };
    }

    private RoomModel GetRoomAtPosition(Vector2Int position, List<RoomModel> rooms)
    {
        return rooms.FirstOrDefault(room => room.ContainsPosition(position));
    }
}

// -------------------- //
// Scripts/Generators/PartitionGenerator.cs
// -------------------- //

using System.Collections.Generic;
using UnityEngine;

public class PartitionGenerator
{
    public PartitionModel GeneratePartitionTree(LevelModel level, PartitionConfig partitionConfig, System.Random random)
    {
        PartitionModel rootPartition = new(new RectInt(0, 0, level.Width, level.Height));
        
        SplitRecursively(rootPartition, partitionConfig, random);
        
        Debug.Log("PartitionGenerator.GeneratePartitionTree(): Generated partition tree successfully.");
        return rootPartition;
    }
    
    private void SplitRecursively(PartitionModel partition, PartitionConfig config, System.Random random)
    {
        bool canSplitVert = (partition.Height >= (PartitionModel.MIN_SIZE * 2 + 1));
        bool canSplitHorz = (partition.Width >= (PartitionModel.MIN_SIZE * 2 + 1));

        if (!canSplitVert && !canSplitHorz) return;

        bool splitVert;

        if (canSplitVert && canSplitHorz) splitVert = (partition.Height > partition.Width);
        else if (canSplitVert) splitVert = true;
        else splitVert = false;

        float splitRatio = (float)(random.NextDouble() * (config.MaxSplitRatio - config.MinSplitRatio) + config.MinSplitRatio);
        
        if (splitVert) SplitVert(partition, splitRatio);
        else SplitHorz(partition, splitRatio);

        SplitRecursively(partition.LeftChild, config, random);
        SplitRecursively(partition.RightChild, config, random);
    }

    private void SplitVert(PartitionModel partition, float splitRatio)
    {
        int minSplit = PartitionModel.MIN_SIZE;
        int maxSplit = partition.Width - PartitionModel.MIN_SIZE;

        if (maxSplit <= minSplit) return;

        int splitPoint = Mathf.Clamp(
            Mathf.RoundToInt(partition.Width * splitRatio),
            minSplit,
            maxSplit
        );

        partition.LeftChild = new(new RectInt(partition.X, partition.Y, splitPoint, partition.Height));
        partition.RightChild = new(new RectInt(partition.X + splitPoint, partition.Y, partition.Width - splitPoint, partition.Height));
    }

    private void SplitHorz(PartitionModel partition, float splitRatio)
    {
        int minSplit = PartitionModel.MIN_SIZE;
        int maxSplit = partition.Height - PartitionModel.MIN_SIZE;
        
        if (maxSplit <= minSplit) return;

        int splitPoint = Mathf.Clamp(
            Mathf.RoundToInt(partition.Height * splitRatio),
            minSplit,
            maxSplit
        );

        partition.LeftChild = new(new RectInt(partition.X, partition.Y, partition.Width, splitPoint));
        partition.RightChild = new(new RectInt(partition.X, partition.Y + splitPoint, partition.Width, partition.Height - splitPoint));
    }

    public List<PartitionModel> CollectLeaves(PartitionModel rootPartition)
    {
        List<PartitionModel> leaves = new();

        GetLeavesRecursively(rootPartition, leaves);

        Debug.Log("PartitionGenerator.CollectLeaves(): Collected all leaf partitions successfully.");
        return leaves;
    }

    private void GetLeavesRecursively(PartitionModel partition, List<PartitionModel> leaves)
    {
        if (partition == null) return;
        
        if (partition.IsLeaf) leaves.Add(partition);
        else
        {
            GetLeavesRecursively(partition.LeftChild, leaves);
            GetLeavesRecursively(partition.RightChild, leaves);
        }
    }
}

using UnityEngine;
using System.Collections.Generic;

// WARNING!: This code was derived from legacy code. There are several errors and outdated processes in this code.
public class RoomGenerator
{
    public List<RoomModel> CreateRoomsFromPartitions(List<PartitionModel> leaves, RoomModel roomModel, System.Random random)
    {
        var rooms = new List<RoomModel>();
        int roomIdCounter = 0;
        
        foreach (var leaf in leaves)
        {
            if (leaf == null) continue;

            var room = CreateRoomInPartition(leaf, roomModel, random, roomIdCounter);
            if (room != null)
            {
                rooms.Add(room);
                leaf.Room = room;
                roomIdCounter++;
            }
        }
        
        Debug.Log($"Created {rooms.Count} rooms from {leaves.Count} partitions");
        return rooms;
    }

    private RoomModel CreateRoomInPartition(PartitionModel leaf, RoomModel room, System.Random random, int roomId)
    {
        // Calculate maximum possible insets
        int maxHorizontalInset = (leaf.Bounds.width - room.MIN_SIZE) / 2;
        int maxVerticalInset = (leaf.Bounds.height - room.MIN_SIZE) / 2;
        
        // Clamp insets to safe values
        int leftInset = Mathf.Clamp(random.Next(room.MIN_INSET, room.MAX_INSET + 1), 1, maxHorizontalInset);
        int rightInset = Mathf.Clamp(random.Next(room.MIN_INSET, room.MAX_INSET + 1), 1, maxHorizontalInset);
        int bottomInset = Mathf.Clamp(random.Next(room.MIN_INSET, room.MAX_INSET + 1), 1, maxVerticalInset);
        int topInset = Mathf.Clamp(random.Next(room.MIN_INSET, room.MAX_INSET + 1), 1, maxVerticalInset);

        // Ensure we have at least a minimum room size
        int roomWidth = leaf.Bounds.width - (leftInset + rightInset);
        int roomHeight = leaf.Bounds.height - (bottomInset + topInset);
        
        // FIX: Force minimum room size and ensure we have at least 3x3 for floors
        if (roomWidth < 3 || roomHeight < 3)
        {
            Debug.LogWarning($"Partition too small for room: {leaf.Bounds}. Adjusting insets...");
            
            // Use minimal insets to create smallest possible room
            leftInset = 1;
            rightInset = 1;
            bottomInset = 1;
            topInset = 1;
            
            roomWidth = Mathf.Max(3, leaf.Bounds.width - 2);
            roomHeight = Mathf.Max(3, leaf.Bounds.height - 2);
        }

        // Ensure room meets minimum size requirements
        if (roomWidth < room.MIN_SIZE || roomHeight < room.MIN_SIZE)
        {
            // Adjust insets to meet minimum size
            int neededWidth = room.MIN_SIZE - roomWidth;
            int neededHeight = room.MIN_SIZE - roomHeight;
            
            leftInset = Mathf.Max(1, leftInset - neededWidth / 2);
            rightInset = Mathf.Max(1, rightInset - neededWidth / 2);
            bottomInset = Mathf.Max(1, bottomInset - neededHeight / 2);
            topInset = Mathf.Max(1, topInset - neededHeight / 2);
            
            roomWidth = leaf.Bounds.width - (leftInset + rightInset);
            roomHeight = leaf.Bounds.height - (bottomInset + topInset);
        }

        RectInt roomBounds = new RectInt(
            leaf.Bounds.x + leftInset,
            leaf.Bounds.y + bottomInset,
            roomWidth,
            roomHeight
        );

        // Final safety check
        if (roomBounds.width >= 3 && roomBounds.height >= 3)
        {
            var room = new RoomModel(roomBounds, roomId, RoomType.Combat);
            Debug.Log($"Created room {room.ID}: {roomBounds} (Size: {roomBounds.width}x{roomBounds.height})");
            return room;
        }
        else
        {
            Debug.LogWarning($"Skipped room creation - bounds too small: {roomBounds}");
            return null;
        }
    }

    /// <summary>
    /// Finds and assigns neighboring partitions for corridor generation.
    /// </summary>
    public void FindAndAssignNeighbors(List<PartitionModel> partitions)
    {
        if (partitions == null) return;

        foreach (var partition in partitions)
            partition.Neighbors.Clear();

        var rightEdgeMap = new Dictionary<int, List<PartitionModel>>();
        var bottomEdgeMap = new Dictionary<int, List<PartitionModel>>();

        // Build edge maps for efficient neighbor finding
        foreach (var partition in partitions)
        {
            if (partition == null) continue;

            // Right edge mapping
            if (!rightEdgeMap.ContainsKey(partition.Bounds.xMax))
                rightEdgeMap[partition.Bounds.xMax] = new List<PartitionModel>();
            rightEdgeMap[partition.Bounds.xMax].Add(partition);
            
            // Bottom edge mapping
            if (!bottomEdgeMap.ContainsKey(partition.Bounds.yMax))
                bottomEdgeMap[partition.Bounds.yMax] = new List<PartitionModel>();
            bottomEdgeMap[partition.Bounds.yMax].Add(partition);
        }

        // Find horizontal neighbors
        foreach (var partition in partitions)
        {
            if (partition == null) continue;

            if (rightEdgeMap.TryGetValue(partition.Bounds.xMin, out var horizontalCandidates))
            {
                FindValidNeighbors(partition, horizontalCandidates);
            }

            if (bottomEdgeMap.TryGetValue(partition.Bounds.yMin, out var verticalCandidates))
            {
                FindValidNeighbors(partition, verticalCandidates);
            }
        }
    }

    private void FindValidNeighbors(PartitionModel partition, List<PartitionModel> candidates)
    {
        foreach (var candidate in candidates)
        {
            if (candidate == null || candidate == partition) continue;

            if (ArePartitionsNeighbors(partition.Bounds, candidate.Bounds))
            {
                if (!partition.Neighbors.Contains(candidate))
                    partition.Neighbors.Add(candidate);
                if (!candidate.Neighbors.Contains(partition))
                    candidate.Neighbors.Add(partition);
            }
        }
    }

    private bool ArePartitionsNeighbors(RectInt boundsA, RectInt boundsB)
    {
        bool touchHorizontally = boundsA.xMax == boundsB.xMin || boundsB.xMax == boundsA.xMin;
        bool touchVertically = boundsA.yMax == boundsB.yMin || boundsB.yMax == boundsA.yMin;

        bool overlapX = boundsA.xMin < boundsB.xMax && boundsB.xMin < boundsA.xMax;
        bool overlapY = boundsA.yMin < boundsB.yMax && boundsB.yMin < boundsA.yMax;

        return (touchHorizontally && overlapY) || (touchVertically && overlapX);
    }
}