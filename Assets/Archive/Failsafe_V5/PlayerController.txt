using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections;
using System.Linq;

namespace Player
{
    public class PlayerController : MonoBehaviour
    {
        [Header("Mobile Controls")]
        public bool IsMobile = false;
        public float TouchLookSensitivity { get; private set; } = 100;
        public GameObject MobileUI;
        private Vector2 _touchLookInput = Vector2.zero;
        private Vector2 _touchMoveInput = Vector2.zero;
        
        [Header("Mouse Look")]
        [Range(0, 100)] public float mouseSensitivity = 50f;
        [Range(0f, 200f)] private float snappiness = 100f;
        
        [Header("Movement Speeds")]
        [Range(0f, 20f)] public float walkSpeed = 3f;
        [Range(0f, 30f)] public float sprintSpeed = 5f;
        [Range(0f, 10f)] public float crouchSpeed = 1.5f;
        
        [Header("Crouch Settings")]
        public float crouchHeight = 1f;
        public float crouchCameraHeight = 1f;
        
        [Header("Slide Settings")]
        public float slideSpeed = 8f;
        public float slideDuration = 0.7f;
        public float slideFovBoost = 5f;
        public float slideTiltAngle = 5f;
        
        [Header("Jump & Gravity")]
        [Range(0f, 15f)] public float jumpSpeed = 3f;
        [Range(0f, 50f)] public float gravity = 9.81f;
        public bool coyoteTimeEnabled = true;
        [Range(0.01f, 0.3f)] public float coyoteTimeDuration = 0.2f;
        
        [Header("Camera Effects")]
        public float normalFov = 60f;
        public float sprintFov = 70f;
        public float fovChangeSpeed = 5f;
        public float walkingBobbingSpeed = 10f;
        public float bobbingAmount = 0.05f;
        private float sprintBobMultiplier = 1.5f;
        private float recoilReturnSpeed = 8f;
        
        [Header("Ability Toggles")]
        public bool canSlide = true;
        public bool canJump = true;
        public bool canSprint = true;
        public bool canCrouch = true;
        
        [Header("Collision Detection")]
        public QueryTriggerInteraction ceilingCheckQueryTriggerInteraction = QueryTriggerInteraction.Ignore;
        public QueryTriggerInteraction groundCheckQueryTriggerInteraction = QueryTriggerInteraction.Ignore;
        public Transform groundCheck;
        public float groundDistance = 0.2f;
        public LayerMask groundMask;
        
        [Header("Performance Optimization")]
        [Range(1, 10)] public int RoomDetectionFrequency = 3; // Check every 3 frames
        public float InteractionRange = 3f;
        public LayerMask InteractionLayerMask;
        
        [Header("Camera References")]
        public Transform playerCamera;
        public Transform cameraParent;
        
        [Header("Player Stats")]
        public int Health = 100;
        public int MaxHealth = 100;
        
        [Header("Interaction")]
        public KeyCode InteractKey = KeyCode.E;

        // Private state variables
        private float rotX, rotY;
        private float xVelocity, yVelocity;
        private CharacterController characterController;
        private Vector3 moveDirection = Vector3.zero;
        private bool isGrounded;
        private Vector2 moveInput;
        public bool isSprinting;
        public bool isCrouching;
        public bool isSliding;
        private float slideTimer;
        private float postSlideCrouchTimer;
        private Vector3 slideDirection;
        private float originalHeight;
        private float originalCameraParentHeight;
        private float coyoteTimer;
        private Camera cam;
        private AudioSource slideAudioSource;
        private float bobTimer;
        private float defaultPosY;
        private Vector3 recoil = Vector3.zero;
        private bool isLook = true, isMove = true;
        private float currentCameraHeight;
        private float currentBobOffset;
        private float currentFov;
        private float fovVelocity;
        private float currentSlideSpeed;
        private float slideSpeedVelocity;
        private float currentTiltAngle;
        private float tiltVelocity;

        // Optimized room detection
        private RoomAssignment _currentRoom;
        private DungeonGenerator _cachedDungeonGenerator;
        private int _frameCount = 0;
        private bool _inCombat = false;
        private RoomAssignment _combatRoom;
        
        // Mobile interaction
        private bool _mobileInteractPressed = false;
        private bool _mobileJumpPressed = false;

        // Events
        public System.Action<RoomAssignment> OnRoomEntered;
        public System.Action<RoomAssignment> OnRoomExited;
        public System.Action<int> OnHealthChanged;
        public System.Action OnPlayerDeath;

        public float CurrentCameraHeight => isCrouching || isSliding ? crouchCameraHeight : originalCameraParentHeight;

        private void Awake()
        {
            characterController = GetComponent<CharacterController>();
            cam = playerCamera.GetComponent<Camera>();
            originalHeight = characterController.height;
            originalCameraParentHeight = cameraParent.localPosition.y;
            defaultPosY = cameraParent.localPosition.y;
            slideAudioSource = gameObject.AddComponent<AudioSource>();
            slideAudioSource.playOnAwake = false;
            slideAudioSource.loop = false;

            float scale = 0.5f; // Your player scale
            characterController.height = originalHeight * scale;
            characterController.radius = characterController.radius * scale;
            characterController.center = new Vector3(0f, characterController.height * 0.5f, 0f);
            
            // Also adjust ground check distance for scale
            groundDistance = 0.2f * scale;
            
            Cursor.lockState = CursorLockMode.Locked;
            currentCameraHeight = originalCameraParentHeight;
            currentBobOffset = 0f;
            currentFov = normalFov;
            currentSlideSpeed = 0f;
            currentTiltAngle = 0f;

            rotX = transform.rotation.eulerAngles.y;
            rotY = playerCamera.localRotation.eulerAngles.x;
            xVelocity = rotX;
            yVelocity = rotY;

            // Cache dungeon generator
            _cachedDungeonGenerator = FindObjectOfType<DungeonGenerator>();
            
            // Setup mobile controls
            SetupMobileControls();
        }

        private void Start()
        {
            SpawnAtEntrance();
        }

        private void Update()
        {
            _frameCount++;
            
            // Optimized: Only check room detection every N frames
            if (_frameCount % RoomDetectionFrequency == 0)
            {
                HandleRoomDetection();
            }
            
            HandleInput();
            HandleInteraction();
            
            isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask, groundCheckQueryTriggerInteraction);
            if (isGrounded && moveDirection.y < 0)
            {
                moveDirection.y = -2f;
                coyoteTimer = coyoteTimeEnabled ? coyoteTimeDuration : 0f;
            }
            else if (coyoteTimeEnabled)
            {
                coyoteTimer -= Time.deltaTime;
            }

            if (isLook)
            {
                HandleLookInput();
            }

            HandleHeadBob();
            HandleCrouchAndSlide();
            HandleMovement();
        }

        #region Optimized Input Handling
        private void HandleInput()
        {
            if (IsMobile)
            {
                HandleMobileInput();
            }
            else
            {
                HandleDesktopInput();
            }
        }

        private void HandleMobileInput()
        {
            // Handle movement (left side of screen)
            _touchMoveInput = GetLeftTouchInput();
            moveInput.x = _touchMoveInput.x;
            moveInput.y = _touchMoveInput.y;

            // Handle look (right side of screen)  
            _touchLookInput = GetRightTouchInput();

            if (_touchLookInput.magnitude > 0.1f)
            {
                float mouseX = _touchLookInput.x * TouchLookSensitivity * Time.deltaTime;
                float mouseY = _touchLookInput.y * TouchLookSensitivity * Time.deltaTime;

                rotX += mouseX;
                rotY -= mouseY;
                rotY = Mathf.Clamp(rotY, -90f, 90f);

                xVelocity = Mathf.Lerp(xVelocity, rotX, snappiness * Time.deltaTime);
                yVelocity = Mathf.Lerp(yVelocity, rotY, snappiness * Time.deltaTime);

                playerCamera.transform.localRotation = Quaternion.Euler(yVelocity, 0f, 0f);
                transform.rotation = Quaternion.Euler(0f, xVelocity, 0f);
            }

            // Mobile-specific actions
            isSprinting = canSprint && moveInput.y > 0.7f && isGrounded && !isCrouching && !isSliding;
        }

        private Vector2 GetLeftTouchInput()
        {
            // Simple left-side touch detection
            if (Input.touchCount > 0)
            {
                foreach (Touch touch in Input.touches)
                {
                    if (touch.position.x < Screen.width / 2)
                    {
                        // Convert touch delta to movement input
                        return new Vector2(
                            Mathf.Clamp(touch.deltaPosition.x * 0.01f, -1f, 1f),
                            Mathf.Clamp(touch.deltaPosition.y * 0.01f, -1f, 1f)
                        );
                    }
                }
            }
            return Vector2.zero;
        }
        
        private Vector2 GetRightTouchInput()
        {
            // Simple right-side touch detection for looking
            if (Input.touchCount > 0)
            {
                foreach (Touch touch in Input.touches)
                {
                    if (touch.position.x > Screen.width / 2)
                    {
                        return new Vector2(
                            touch.deltaPosition.x * TouchLookSensitivity,
                            touch.deltaPosition.y * TouchLookSensitivity
                        );
                    }
                }
            }
            return Vector2.zero;
        }

        private void HandleDesktopInput()
        {
            moveInput.x = Input.GetAxis("Horizontal");
            moveInput.y = Input.GetAxis("Vertical");
            isSprinting = canSprint && Input.GetKey(KeyCode.LeftShift) && moveInput.y > 0.1f && isGrounded && !isCrouching && !isSliding;
        }

        private void HandleLookInput()
        {
            float mouseX = Input.GetAxis("Mouse X") * 10 * mouseSensitivity * Time.deltaTime;
            float mouseY = Input.GetAxis("Mouse Y") * 10 * mouseSensitivity * Time.deltaTime;

            rotX += mouseX;
            rotY -= mouseY;
            rotY = Mathf.Clamp(rotY, -90f, 90f);

            xVelocity = Mathf.Lerp(xVelocity, rotX, snappiness * Time.deltaTime);
            yVelocity = Mathf.Lerp(yVelocity, rotY, snappiness * Time.deltaTime);

            float targetTiltAngle = isSliding ? slideTiltAngle : 0f;
            currentTiltAngle = Mathf.SmoothDamp(currentTiltAngle, targetTiltAngle, ref tiltVelocity, 0.2f);
            playerCamera.transform.localRotation = Quaternion.Euler(yVelocity - currentTiltAngle, 0f, 0f);
            transform.rotation = Quaternion.Euler(0f, xVelocity, 0f);
        }

        // Mobile button handlers
        public void OnMobileInteract()
        {
            _mobileInteractPressed = true;
        }

        public void OnMobileJump()
        {
            _mobileJumpPressed = true;
        }

        private void SetupMobileControls()
        {
            if (IsMobile && MobileUI != null)
            {
                MobileUI.SetActive(true);
            }
            else if (MobileUI != null)
            {
                MobileUI.SetActive(false);
            }
        }
        #endregion

        #region Optimized Room Detection
        private void HandleRoomDetection()
        {
            if (_cachedDungeonGenerator == null || _cachedDungeonGenerator.CurrentRoomAssignments == null) 
            {
                // Try to re-cache if null
                _cachedDungeonGenerator = FindObjectOfType<DungeonGenerator>();
                return;
            }

            Vector2Int playerGridPos = new Vector2Int(
                Mathf.FloorToInt(transform.position.x),
                Mathf.FloorToInt(transform.position.z)
            );

            // Use the layout's optimized spatial lookup
            var layout = _cachedDungeonGenerator.CurrentLayout;
            if (layout != null)
            {
                var newRoom = layout.GetRoomAtPosition(playerGridPos);
                if (newRoom != null)
                {
                    var newRoomAssignment = _cachedDungeonGenerator.CurrentRoomAssignments
                        .FirstOrDefault(ra => ra.Room == newRoom);
                    
                    if (newRoomAssignment != null && _currentRoom != newRoomAssignment)
                    {
                        ChangeRoom(newRoomAssignment);
                    }
                }
                else if (_currentRoom != null)
                {
                    ExitCurrentRoom();
                }
            }
        }

        private void ChangeRoom(RoomAssignment newRoom)
        {
            var previousRoom = _currentRoom;
            _currentRoom = newRoom;
            
            OnRoomExited?.Invoke(previousRoom);
            OnRoomEntered?.Invoke(newRoom);
            
            HandleRoomEntry(newRoom);
        }

        private void ExitCurrentRoom()
        {
            OnRoomExited?.Invoke(_currentRoom);
            _currentRoom = null;
        }

        private void HandleRoomEntry(RoomAssignment room)
        {
            switch (room.Type)
            {
                case RoomType.Combat:
                case RoomType.Boss:
                    if (room.State == RoomState.Closed && !_inCombat)
                    {
                        StartCombat(room);
                    }
                    break;
                    
                case RoomType.Shop:
                    Debug.Log("Welcome to the shop!");
                    break;
                    
                case RoomType.Treasure:
                    Debug.Log("You found treasure!");
                    break;
                    
                case RoomType.Exit:
                    if (AllCombatRoomsCompleted())
                    {
                        Debug.Log("Exit room - ready for next floor!");
                    }
                    else
                    {
                        Debug.Log("Exit room locked! Clear all combat rooms first.");
                    }
                    break;
            }
        }

        private void StartCombat(RoomAssignment room)
        {
            _inCombat = true;
            _combatRoom = room;
            
            // Lock the room
            room.State = RoomState.Closed;
            
            Debug.Log($"Combat initiated in {room.Type} room!");
            
            // Here you would spawn enemies
            // SpawnEnemiesInRoom(room);
        }

        public void EndCombat(RoomAssignment room)
        {
            if (_inCombat && _combatRoom == room)
            {
                _inCombat = false;
                room.State = RoomState.Completed;
                _combatRoom = null;
                
                Debug.Log("Combat completed!");
                
                // Check if player can now exit
                if (room.Type == RoomType.Boss)
                {
                    UnlockExitRoom();
                }
            }
        }

        private bool AllCombatRoomsCompleted()
        {
            if (_cachedDungeonGenerator?.CurrentRoomAssignments == null) return false;
            
            return !_cachedDungeonGenerator.CurrentRoomAssignments
                .Any(room => (room.Type == RoomType.Combat || room.Type == RoomType.Boss) 
                            && room.State != RoomState.Completed);
        }

        private void UnlockExitRoom()
        {
            if (_cachedDungeonGenerator?.CurrentRoomAssignments == null) return;
            
            var exitRoom = _cachedDungeonGenerator.CurrentRoomAssignments
                .FirstOrDefault(room => room.Type == RoomType.Exit);
                
            if (exitRoom != null)
            {
                exitRoom.State = RoomState.Open;
                Debug.Log("Exit room unlocked!");
            }
        }
        #endregion

        #region Enhanced Interaction System
        private void HandleInteraction()
        {
            if (Input.GetKeyDown(InteractKey) || _mobileInteractPressed)
            {
                TryInteract();
                _mobileInteractPressed = false;
            }
        }

        private void TryInteract()
        {
            // First try raycast for nearby interactables
            if (TryRaycastInteraction())
                return;
            
            // Fallback to room-based interaction
            if (_currentRoom != null)
            {
                HandleRoomInteraction(_currentRoom);
            }
        }

        private bool TryRaycastInteraction()
        {
            RaycastHit hit;
            if (Physics.Raycast(playerCamera.position, playerCamera.forward, out hit, InteractionRange, InteractionLayerMask))
            {
                var interactable = hit.collider.GetComponent<IInteractable>();
                if (interactable != null)
                {
                    interactable.Interact(this);
                    return true;
                }
            }
            return false;
        }

        private void HandleRoomInteraction(RoomAssignment room)
        {
            switch (room.Type)
            {
                case RoomType.Shop:
                    OpenShopInterface();
                    break;
                    
                case RoomType.Treasure:
                    OpenTreasureChest();
                    break;
                    
                case RoomType.Exit:
                    if (AllCombatRoomsCompleted() && _cachedDungeonGenerator != null)
                    {
                        _cachedDungeonGenerator.GenerateNextFloor();
                    }
                    else
                    {
                        Debug.Log("Cannot exit yet! Clear all combat rooms.");
                    }
                    break;
            }
        }

        // Placeholder methods - implement these based on your game design
        private void OpenShopInterface()
        {
            Debug.Log("Opening shop interface!");
            // Implement shop UI
        }

        private void OpenTreasureChest()
        {
            Debug.Log("Opening treasure chest!");
            // Implement treasure collection
        }
        #endregion

        #region Movement & Camera (Optimized)
        private void HandleCrouchAndSlide()
        {
            bool wantsToCrouch = canCrouch && (IsMobile ? moveInput.y < -0.5f : Input.GetKey(KeyCode.LeftControl)) && !isSliding;
            
            float scale = 0.5f; // Your player scale
    
            // Adjust ceiling check for scale
            Vector3 point1 = transform.position + characterController.center - Vector3.up * (characterController.height * 0.5f);
            Vector3 point2 = point1 + Vector3.up * characterController.height * 0.6f;
            float capsuleRadius = characterController.radius * 0.95f;
            float castDistance = isSliding ? (originalHeight * scale) + 0.2f : (originalHeight * scale) - (crouchHeight * scale) + 0.2f;
            bool hasCeiling = Physics.CapsuleCast(point1, point2, capsuleRadius, Vector3.up, castDistance, groundMask, ceilingCheckQueryTriggerInteraction);
            
            if (isSliding)
            {
                postSlideCrouchTimer = 0.3f;
            }
            if (postSlideCrouchTimer > 0)
            {
                postSlideCrouchTimer -= Time.deltaTime;
                isCrouching = canCrouch;
            }
            else
            {
                isCrouching = canCrouch && (wantsToCrouch || (hasCeiling && !isSliding));
            }

            if (canSlide && isSprinting && (IsMobile ? moveInput.y > 0.8f : Input.GetKeyDown(KeyCode.LeftControl)) && isGrounded)
            {
                isSliding = true;
                slideTimer = slideDuration;
                slideDirection = moveInput.magnitude > 0.1f ? (transform.right * moveInput.x + transform.forward * moveInput.y).normalized : transform.forward;
                currentSlideSpeed = sprintSpeed;
            }

            float slideProgress = slideTimer / slideDuration;
            if (isSliding)
            {
                slideTimer -= Time.deltaTime;
                if (slideTimer <= 0f || !isGrounded)
                {
                    isSliding = false;
                }
                float targetSlideSpeed = slideSpeed * Mathf.Lerp(0.7f, 1f, slideProgress);
                currentSlideSpeed = Mathf.SmoothDamp(currentSlideSpeed, targetSlideSpeed, ref slideSpeedVelocity, 0.2f);
                characterController.Move(slideDirection * currentSlideSpeed * Time.deltaTime);
            }

            float targetHeight = isCrouching || isSliding ? crouchHeight * scale : originalHeight * scale;
            characterController.height = Mathf.Lerp(characterController.height, targetHeight, Time.deltaTime * 10f);
            characterController.center = new Vector3(0f, characterController.height * 0.5f, 0f);

            float targetFov = isSprinting ? sprintFov : (isSliding ? sprintFov + (slideFovBoost * Mathf.Lerp(0f, 1f, 1f - slideProgress)) : normalFov);
            currentFov = Mathf.SmoothDamp(currentFov, targetFov, ref fovVelocity, 1f / fovChangeSpeed);
            cam.fieldOfView = currentFov;
        }

        private void HandleHeadBob()
        {
            Vector3 horizontalVelocity = new Vector3(characterController.velocity.x, 0f, characterController.velocity.z);
            bool isMovingEnough = horizontalVelocity.magnitude > 0.1f;

            float targetBobOffset = isMovingEnough ? Mathf.Sin(bobTimer) * bobbingAmount : 0f;
            currentBobOffset = Mathf.Lerp(currentBobOffset, targetBobOffset, Time.deltaTime * walkingBobbingSpeed);

            if (!isGrounded || isSliding || isCrouching)
            {
                bobTimer = 0f;
                float targetCameraHeight = isCrouching || isSliding ? crouchCameraHeight : originalCameraParentHeight;
                currentCameraHeight = Mathf.Lerp(currentCameraHeight, targetCameraHeight, Time.deltaTime * 10f);
                cameraParent.localPosition = new Vector3(
                    cameraParent.localPosition.x,
                    currentCameraHeight + currentBobOffset,
                    cameraParent.localPosition.z);
                recoil = Vector3.zero;
                cameraParent.localRotation = Quaternion.RotateTowards(cameraParent.localRotation, Quaternion.Euler(recoil), recoilReturnSpeed * Time.deltaTime);
                return;
            }

            if (isMovingEnough)
            {
                float bobSpeed = walkingBobbingSpeed * (isSprinting ? sprintBobMultiplier : 1f);
                bobTimer += Time.deltaTime * bobSpeed;
                float targetCameraHeight = isCrouching || isSliding ? crouchCameraHeight : originalCameraParentHeight;
                currentCameraHeight = Mathf.Lerp(currentCameraHeight, targetCameraHeight, Time.deltaTime * 10f);
                cameraParent.localPosition = new Vector3(
                    cameraParent.localPosition.x,
                    currentCameraHeight + currentBobOffset,
                    cameraParent.localPosition.z);
                recoil.z = moveInput.x * -2f;
            }
            else
            {
                bobTimer = 0f;
                float targetCameraHeight = isCrouching || isSliding ? crouchCameraHeight : originalCameraParentHeight;
                currentCameraHeight = Mathf.Lerp(currentCameraHeight, targetCameraHeight, Time.deltaTime * 10f);
                cameraParent.localPosition = new Vector3(
                    cameraParent.localPosition.x,
                    currentCameraHeight + currentBobOffset,
                    cameraParent.localPosition.z);
                recoil = Vector3.zero;
            }

            cameraParent.localRotation = Quaternion.RotateTowards(cameraParent.localRotation, Quaternion.Euler(recoil), recoilReturnSpeed * Time.deltaTime);
        }

        private void HandleMovement()
        {
            float currentSpeed = isCrouching ? crouchSpeed : (isSprinting ? sprintSpeed : walkSpeed);
            if (!isMove) currentSpeed = 0f;

            Vector3 direction = new Vector3(moveInput.x, 0f, moveInput.y);
            Vector3 moveVector = transform.TransformDirection(direction) * currentSpeed;
            moveVector = Vector3.ClampMagnitude(moveVector, currentSpeed);

            if (isGrounded || coyoteTimer > 0f)
            {
                if ((canJump && Input.GetKeyDown(KeyCode.Space) && !isSliding) || _mobileJumpPressed)
                {
                    moveDirection.y = jumpSpeed;
                    _mobileJumpPressed = false;
                }
                else if (moveDirection.y < 0)
                {
                    moveDirection.y = -2f;
                }
            }
            else
            {
                moveDirection.y -= gravity * Time.deltaTime;
            }

            if (!isSliding)
            {
                moveDirection = new Vector3(moveVector.x, moveDirection.y, moveVector.z);
                characterController.Move(moveDirection * Time.deltaTime);
            }
        }
        #endregion

        #region Roguelike Systems
        private void SpawnAtEntrance()
        {
            if (_cachedDungeonGenerator != null && _cachedDungeonGenerator.CurrentRoomAssignments != null)
            {
                var entranceRoom = _cachedDungeonGenerator.CurrentRoomAssignments
                    .FirstOrDefault(room => room.Type == RoomType.Entrance);
                    
                if (entranceRoom != null)
                {
                    Vector3 roomCenter = new Vector3(
                        entranceRoom.Room.Bounds.center.x,
                        0.5f + characterController.height * 0.5f, // Spawn above floor
                        entranceRoom.Room.Bounds.center.y
                    );
                    
                    TeleportToPosition(roomCenter);
                    _currentRoom = entranceRoom;
                    
                    Debug.Log($"Player spawned in {entranceRoom.Type} room at {roomCenter}");
                }
                else
                {
                    Debug.LogWarning("No entrance room found! Spawning at world center.");
                    TeleportToPosition(Vector3.up * (0.5f + characterController.height * 0.5f));
                }
            }
            else
            {
                Debug.LogWarning("DungeonGenerator not found! Spawning at world center.");
                TeleportToPosition(Vector3.up * (0.5f + characterController.height * 0.5f));
            }
        }

        public void TakeDamage(int damage)
        {
            Health = Mathf.Max(0, Health - damage);
            OnHealthChanged?.Invoke(Health);
            
            Debug.Log($"Player took {damage} damage. Health: {Health}/{MaxHealth}");
            
            if (Health <= 0)
            {
                Die();
            }
        }

        public void Heal(int amount)
        {
            Health = Mathf.Min(MaxHealth, Health + amount);
            OnHealthChanged?.Invoke(Health);
            Debug.Log($"Player healed {amount}. Health: {Health}/{MaxHealth}");
        }

        public void RestoreFullHealth()
        {
            Health = MaxHealth;
            OnHealthChanged?.Invoke(Health);
            Debug.Log("Player health fully restored!");
        }

        private void Die()
        {
            Debug.Log("Player died!");
            OnPlayerDeath?.Invoke();
            
            // Reset player
            Health = MaxHealth;
            SpawnAtEntrance();
        }

        public void IncreaseMaxHealth(int amount)
        {
            MaxHealth += amount;
            Health += amount;
            OnHealthChanged?.Invoke(Health);
            Debug.Log($"Max health increased by {amount}. New max: {MaxHealth}");
        }

        // Roguelike progression
        private int _gold = 0;
        public int Gold => _gold;

        public void AddGold(int amount)
        {
            _gold += amount;
            Debug.Log($"Gained {amount} gold. Total: {_gold}");
        }

        public bool SpendGold(int amount)
        {
            if (_gold >= amount)
            {
                _gold -= amount;
                Debug.Log($"Spent {amount} gold. Remaining: {_gold}");
                return true;
            }
            return false;
        }
        #endregion

        #region Public Methods
        public void SetControl(bool newState)
        {
            SetLookControl(newState);
            SetMoveControl(newState);
        }

        public void SetLookControl(bool newState)
        {
            isLook = newState;
        }

        public void SetMoveControl(bool newState)
        {
            isMove = newState;
        }

        public void SetCursorVisibility(bool newVisibility)
        {
            Cursor.lockState = newVisibility ? CursorLockMode.None : CursorLockMode.Locked;
            Cursor.visible = newVisibility;
        }

        public RoomAssignment GetCurrentRoom()
        {
            return _currentRoom;
        }

        public bool IsInCombatRoom()
        {
            return _currentRoom != null && 
                  (_currentRoom.Type == RoomType.Combat || _currentRoom.Type == RoomType.Boss) &&
                  _currentRoom.State == RoomState.Closed;
        }

        public void TeleportToPosition(Vector3 position)
        {
            characterController.enabled = false;
            transform.position = position;
            characterController.enabled = true;
            Debug.Log($"Player teleported to {position}");
        }
        #endregion
    }

    // Interface for interactable objects
    public interface IInteractable
    {
        void Interact(PlayerController player);
    }
}