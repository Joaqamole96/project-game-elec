using UnityEngine;
using System.Collections.Generic;
using System.Text;

// Single-file floor generator — cleaned & consolidated version.
// Features: BSP rooms, adjacency-first straight corridors, guarded fallbacks, corridor validation, MST pruning, gizmo debug.
public class FloorGenerator : MonoBehaviour
{
    [Header("Floor Settings")]
    public int Width = 30;
    public int Height = 30;
    public int Seed = 0;
    [Tooltip("Partitions smaller than this won't split.")] public int minPartitionSize = 10;

    [Header("Room Insets")]
    public int MinInset = 1;
    public int MaxInset = 2;

    [Header("MST / Graph")]
    [Tooltip("Extra random connections in addition to MST")]
    public int extraConnections = 3;

    // ---------------- Core data ----------------
    private Partition root;
    private List<Partition> leaves = new List<Partition>();
    private List<Room> rooms = new List<Room>();
    private List<Corridor> corridors = new List<Corridor>();
    private List<Vector2Int> doors = new List<Vector2Int>();
    private List<Vector2Int> intersections = new List<Vector2Int>();

    // occupancy grid (true = walkable)
    private bool[,] walkable;

    // ----- Unity lifecycle -----
    void Start() => Generate();

    [ContextMenu("Generate")]
    public void Generate()
    {
        Random.InitState(Seed);

        // reset
        leaves.Clear();
        rooms.Clear();
        corridors.Clear();
        doors.Clear();
        intersections.Clear();
        root = new Partition(new RectInt(0, 0, Width, Height));

        // BSP -> rooms
        Split(root);
        CreateRooms();

        // Build occupancy grid (rooms are obstacles)
        BuildWalkableGrid();

        // Spatial neighbor graph among leaves
        BuildNeighbors();

        // ADJACENCY-FIRST: build adjacency MST and create straight-edge corridors along shared boundaries
        BuildAdjacencyCorridors();

        // If adjacency couldn't fully connect (rare), fall back to MST over neighbors using BFS connectors
        ConnectNeighborsMST_Fallback();

        // Validation: drop stray corridors that do not actually connect two distinct rooms
        ValidateAndPruneCorridors();

        // MST prune: choose minimal set of corridors to keep the whole graph connected
        ApplyMSTToCorridors();

        // rebuild doors + intersections from surviving corridors
        RebuildDoorsAndIntersections();

        // finalise corridors on the walkable grid
        ApplyCorridorsToGrid();

        // debug summary
        DebugRoomGraph();

        Debug.Log($"Generate complete: leaves={leaves.Count} rooms={rooms.Count} corridors={corridors.Count}");
    }

    // ------------------- BSP split & room creation -------------------
    private void Split(Partition p)
    {
        if (p.rect.width <= minPartitionSize || p.rect.height <= minPartitionSize)
        {
            leaves.Add(p);
            return;
        }

        bool vert = (p.rect.width > p.rect.height);
        float ratio = Random.Range(.45f, .55f);

        if (vert)
        {
            int split = Mathf.RoundToInt(p.rect.width * ratio);
            p.left = new Partition(new RectInt(p.rect.x, p.rect.y, split, p.rect.height));
            p.right = new Partition(new RectInt(p.rect.x + split, p.rect.y, p.rect.width - split, p.rect.height));
        }
        else
        {
            int split = Mathf.RoundToInt(p.rect.height * ratio);
            p.left = new Partition(new RectInt(p.rect.x, p.rect.y, p.rect.width, split));
            p.right = new Partition(new RectInt(p.rect.x, p.rect.y + split, p.rect.width, p.rect.height - split));
        }

        Split(p.left);
        Split(p.right);
    }

    private void CreateRooms()
    {
        rooms.Clear();
        int idCounter = 0;
        foreach (var p in leaves)
        {
            int l = Random.Range(MinInset, MaxInset + 1);
            int r = Random.Range(MinInset, MaxInset + 1);
            int b = Random.Range(MinInset, MaxInset + 1);
            int t = Random.Range(MinInset, MaxInset + 1);

            RectInt rr = new RectInt(
                p.rect.x + l,
                p.rect.y + b,
                Mathf.Max(1, p.rect.width - (l + r)),
                Mathf.Max(1, p.rect.height - (b + t))
            );

            var room = new Room(rr, idCounter++);
            p.room = room;
            rooms.Add(room);
        }
    }

    // ------------------- Build spatial neighbor graph of leaf partitions -------------------
    private void BuildNeighbors()
    {
        if (leaves == null || leaves.Count == 0) return;

        foreach (var p in leaves)
        {
            if (p.neighbors == null) p.neighbors = new List<Partition>();
            else p.neighbors.Clear();
        }

        for (int i = 0; i < leaves.Count; i++)
        {
            var a = leaves[i];
            if (a == null) continue;
            for (int j = i + 1; j < leaves.Count; j++)
            {
                var b = leaves[j];
                if (b == null) continue;

                if (AreNeighbors(a.rect, b.rect))
                {
                    a.neighbors.Add(b);
                    b.neighbors.Add(a);
                }
            }
        }
    }

    bool AreNeighbors(RectInt a, RectInt b)
    {
        bool xTouch = a.xMax == b.xMin || b.xMax == a.xMin;
        bool yTouch = a.yMax == b.yMin || b.yMax == a.yMin;

        bool overlapX = a.xMin < b.xMax && b.xMin < a.xMax;
        bool overlapY = a.yMin < b.yMax && b.yMin < a.yMax;

        return (xTouch && overlapY) || (yTouch && overlapX);
    }

    // ------------------- ADJACENCY-FIRST corridor generation -------------------
    private void BuildAdjacencyCorridors()
    {
        // collect unique neighbor pairs
        var pairs = new List<(Partition, Partition)>();
        var seen = new HashSet<long>(); // use combined hash key

        for (int i = 0; i < leaves.Count; i++)
        {
            var a = leaves[i];
            if (a == null || a.neighbors == null) continue;
            foreach (var b in a.neighbors)
            {
                if (b == null) continue;
                long key = GetPairKey(a, b);
                if (seen.Contains(key)) continue;
                seen.Add(key);
                pairs.Add((a, b));
            }
        }

        // adjacency lookup
        var adjacency = new Dictionary<Partition, List<Partition>>();
        foreach (var l in leaves) adjacency[l] = new List<Partition>(l.neighbors ?? new List<Partition>());

        // Prim-like MST among adjacent partitions
        var connected = new HashSet<Partition>();
        List<(Partition A, Partition B)> mstEdges = new List<(Partition A, Partition B)>();
        if (leaves.Count > 0)
        {
            Partition start = leaves[0];
            connected.Add(start);

            while (connected.Count < leaves.Count)
            {
                float best = float.MaxValue;
                Partition bestA = null, bestB = null;

                foreach (var a in connected)
                {
                    foreach (var b in adjacency[a])
                    {
                        if (connected.Contains(b)) continue;
                        if (a.room == null || b.room == null) continue;
                        float d = Vector2.Distance(a.room.rect.center, b.room.rect.center);
                        if (d < best)
                        {
                            best = d;
                            bestA = a;
                            bestB = b;
                        }
                    }
                }

                if (bestA == null || bestB == null) break;
                connected.Add(bestB);
                mstEdges.Add((bestA, bestB));
            }
        }

        var createdEdges = new HashSet<string>();
        foreach (var e in mstEdges)
        {
            CreateBoundaryCorridor(e.A, e.B, createdEdges);
        }

        // Add some extra adjacency edges for loops
        int added = 0, tries = 0;
        while (added < extraConnections && tries < pairs.Count * 3 && pairs.Count > 0)
        {
            tries++;
            var pick = pairs[Random.Range(0, pairs.Count)];
            string k = MakeEdgeKey(pick.Item1, pick.Item2);
            if (createdEdges.Contains(k)) continue;
            if (CreateBoundaryCorridor(pick.Item1, pick.Item2, createdEdges))
            {
                added++;
            }
        }
    }

    private long GetPairKey(Partition a, Partition b)
    {
        int h1 = a.GetHashCode();
        int h2 = b.GetHashCode();
        long min = Mathf.Min(h1, h2);
        long max = Mathf.Max(h1, h2);
        return (min << 32) | (uint)max;
    }

    private string MakeEdgeKey(Partition a, Partition b)
    {
        int h1 = a.GetHashCode(), h2 = b.GetHashCode();
        if (h1 < h2) return h1 + "_" + h2;
        return h2 + "_" + h1;
    }

    // Create a corridor along the exact shared boundary between two touching partitions.
    // Corridor tiles stay outside room interiors. If corridor hits existing corridor, we create an intersection and stop.
    private bool CreateBoundaryCorridor(Partition A, Partition B, HashSet<string> createdEdges)
    {
        if (A == null || B == null) return false;
        if (A.room == null || B.room == null) return false;
        if (!AreNeighbors(A.rect, B.rect)) return false;

        string key = MakeEdgeKey(A, B);
        if (createdEdges.Contains(key)) return false;

        bool verticalBoundary = (A.rect.xMax == B.rect.xMin) || (B.rect.xMax == A.rect.xMin);
        bool horizontalBoundary = (A.rect.yMax == B.rect.yMin) || (B.rect.yMax == A.rect.yMin);

        Vector2Int doorA, doorB;

        if (verticalBoundary)
        {
            bool aIsLeft = A.rect.xMax == B.rect.xMin;
            int spanMinY = Mathf.Max(A.rect.yMin, B.rect.yMin);
            int spanMaxY = Mathf.Min(A.rect.yMax - 1, B.rect.yMax - 1);
            if (spanMinY > spanMaxY) return false;

            int roomOverlapMinY = Mathf.Max(A.room.rect.yMin, B.room.rect.yMin);
            int roomOverlapMaxY = Mathf.Min(A.room.rect.yMax - 1, B.room.rect.yMax - 1);

            int pickY;
            if (roomOverlapMinY <= roomOverlapMaxY && roomOverlapMinY >= spanMinY && roomOverlapMaxY <= spanMaxY)
                pickY = Random.Range(roomOverlapMinY, roomOverlapMaxY + 1);
            else
            {
                int centerY = Mathf.RoundToInt(A.room.rect.center.y);
                pickY = Mathf.Clamp(centerY, spanMinY, spanMaxY);
            }

            // one tile outside the room interior toward neighbor
            doorA = aIsLeft ? new Vector2Int(A.room.rect.xMax, pickY) : new Vector2Int(A.room.rect.xMin - 1, pickY);
            doorB = aIsLeft ? new Vector2Int(B.room.rect.xMin - 1, pickY) : new Vector2Int(B.room.rect.xMax, pickY);
        }
        else if (horizontalBoundary)
        {
            bool aIsBelow = A.rect.yMax == B.rect.yMin;
            int spanMinX = Mathf.Max(A.rect.xMin, B.rect.xMin);
            int spanMaxX = Mathf.Min(A.rect.xMax - 1, B.rect.xMax - 1);
            if (spanMinX > spanMaxX) return false;

            int roomOverlapMinX = Mathf.Max(A.room.rect.xMin, B.room.rect.xMin);
            int roomOverlapMaxX = Mathf.Min(A.room.rect.xMax - 1, B.room.rect.xMax - 1);

            int pickX;
            if (roomOverlapMinX <= roomOverlapMaxX && roomOverlapMinX >= spanMinX && roomOverlapMaxX <= spanMaxX)
                pickX = Random.Range(roomOverlapMinX, roomOverlapMaxX + 1);
            else
            {
                int centerX = Mathf.RoundToInt(A.room.rect.center.x);
                pickX = Mathf.Clamp(centerX, spanMinX, spanMaxX);
            }

            doorA = aIsBelow ? new Vector2Int(pickX, A.room.rect.yMax) : new Vector2Int(pickX, A.room.rect.yMin - 1);
            doorB = aIsBelow ? new Vector2Int(pickX, B.room.rect.yMin - 1) : new Vector2Int(pickX, B.room.rect.yMax);
        }
        else
        {
            return false;
        }

        // nudge doors out of any other rooms and into bounds
        doorA = EnsureDoorIsOutsideAndInBounds(doorA, A.room);
        doorB = EnsureDoorIsOutsideAndInBounds(doorB, B.room);

        // build corridor tiles between doorA and doorB, stopping if we meet an existing corridor (intersection)
        var tiles = new List<Vector2Int>();
        if (doorA.x == doorB.x) // vertical
        {
            int yStart = Mathf.Min(doorA.y, doorB.y);
            int yEnd = Mathf.Max(doorA.y, doorB.y);

            for (int y = yStart; y <= yEnd; y++)
            {
                var t = new Vector2Int(doorA.x, y);
                if (IsPointInsideAnyRoom(t, A.room) || IsPointInsideAnyRoom(t, B.room)) continue;

                if (CorridorTileExists(t))
                {
                    if (!intersections.Contains(t)) intersections.Add(t);
                    tiles.Add(t);
                    break;
                }
                tiles.Add(t);
            }
        }
        else if (doorA.y == doorB.y) // horizontal
        {
            int xStart = Mathf.Min(doorA.x, doorB.x);
            int xEnd = Mathf.Max(doorA.x, doorB.x);

            for (int x = xStart; x <= xEnd; x++)
            {
                var t = new Vector2Int(x, doorA.y);
                if (IsPointInsideAnyRoom(t, A.room) || IsPointInsideAnyRoom(t, B.room)) continue;

                if (CorridorTileExists(t))
                {
                    if (!intersections.Contains(t)) intersections.Add(t);
                    tiles.Add(t);
                    break;
                }
                tiles.Add(t);
            }
        }
        else
        {
            return false;
        }

        // fallback if no tiles
        if (tiles.Count == 0)
        {
            var fallback = GuardedLPath(doorA, doorB, A.room, B.room);
            if (fallback != null && fallback.Count > 0)
            {
                var snappedA = SnapDoorToNearestTile(doorA, fallback);
                var snappedB = SnapDoorToNearestTile(doorB, fallback);

                doors.Add(snappedA);
                doors.Add(snappedB);
                corridors.Add(new Corridor(fallback));
                createdEdges.Add(key);
                return true;
            }
            return false;
        }

        // ensure doors land on corridor tiles; snap if needed
        var finalDoorA = tiles.Contains(doorA) ? doorA : SnapDoorToNearestTile(doorA, tiles);
        var finalDoorB = tiles.Contains(doorB) ? doorB : SnapDoorToNearestTile(doorB, tiles);

        doors.Add(finalDoorA);
        doors.Add(finalDoorB);
        corridors.Add(new Corridor(tiles));
        createdEdges.Add(key);
        return true;
    }

    // returns true if any existing corridor already contains that tile
    private bool CorridorTileExists(Vector2Int t)
    {
        foreach (var c in corridors)
        {
            if (c?.tiles == null) continue;
            foreach (var q in c.tiles) if (q == t) return true;
        }
        return false;
    }

    // ------------------- Grid & BFS pathfinding (fallback) -------------------
    private void BuildWalkableGrid()
    {
        walkable = new bool[Width, Height];

        // default all walkable
        for (int x = 0; x < Width; x++)
            for (int y = 0; y < Height; y++)
                walkable[x, y] = true;

        // mark room interior as blocked (not walkable)
        foreach (var r in rooms)
        {
            for (int x = r.rect.xMin; x < r.rect.xMax; x++)
                for (int y = r.rect.yMin; y < r.rect.yMax; y++)
                {
                    if (InBounds(x, y))
                        walkable[x, y] = false;
                }
        }
    }

    private bool InBounds(int x, int y)
        => x >= 0 && y >= 0 && x < Width && y < Height;

    // BFS grid path (returns path including start and goal) — avoids blocked room tiles
    private List<Vector2Int> FindPathBFS(Vector2Int start, Vector2Int goal)
    {
        var path = new List<Vector2Int>();
        if (!InBounds(start.x, start.y) || !InBounds(goal.x, goal.y)) return path;

        bool[,] visited = new bool[Width, Height];
        Vector2Int[,] parent = new Vector2Int[Width, Height];
        Queue<Vector2Int> q = new Queue<Vector2Int>();

        q.Enqueue(start);
        visited[start.x, start.y] = true;
        parent[start.x, start.y] = new Vector2Int(-1, -1);

        int[] dx = new int[] { 1, -1, 0, 0 };
        int[] dy = new int[] { 0, 0, 1, -1 };

        while (q.Count > 0)
        {
            var cur = q.Dequeue();

            if (cur == goal)
            {
                // reconstruct
                Vector2Int p = cur;
                while (p.x != -1)
                {
                    path.Add(p);
                    p = parent[p.x, p.y];
                }
                path.Reverse();
                return path;
            }

            for (int i = 0; i < 4; i++)
            {
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];
                if (!InBounds(nx, ny)) continue;
                if (visited[nx, ny]) continue;

                if (!walkable[nx, ny] && !(nx == goal.x && ny == goal.y)) continue;

                visited[nx, ny] = true;
                parent[nx, ny] = cur;
                q.Enqueue(new Vector2Int(nx, ny));
            }
        }

        return path;
    }

    // ------------------- Door selection & safe connection (fallback path) -------------------
    private void SafeConnectRooms(Room a, Room b)
    {
        Vector2Int doorA = ComputeExteriorDoorPoint(a.rect, b.rect);
        Vector2Int doorB = ComputeExteriorDoorPoint(b.rect, a.rect);

        if (!InBounds(doorA.x, doorA.y) || !InBounds(doorB.x, doorB.y))
        {
            AddFallbackCorridor(a, b);
            return;
        }

        var path = FindPathBFS(doorA, doorB);

        if (path != null && path.Count > 0)
        {
            doors.Add(doorA); doors.Add(doorB);
            corridors.Add(new Corridor(path));
        }
        else
        {
            AddFallbackCorridor(a, b);
        }
    }

    // Pick a point on room perimeter facing the other rect, then step one tile outward toward the target rect.
    private Vector2Int ComputeExteriorDoorPoint(RectInt from, RectInt toward)
    {
        Vector2 targetCenter = new Vector2(toward.x + toward.width / 2.0f, toward.y + toward.height / 2.0f);

        float cx = Mathf.Clamp(targetCenter.x, from.xMin, from.xMax - 1);
        float cy = Mathf.Clamp(targetCenter.y, from.yMin, from.yMax - 1);

        int px = Mathf.RoundToInt(cx);
        int py = Mathf.RoundToInt(cy);

        if (from.Contains(new Vector2Int(px, py)))
        {
            int leftDist = Mathf.Abs(px - from.xMin);
            int rightDist = Mathf.Abs((from.xMax - 1) - px);
            int downDist = Mathf.Abs(py - from.yMin);
            int upDist = Mathf.Abs((from.yMax - 1) - py);

            int min = Mathf.Min(Mathf.Min(leftDist, rightDist), Mathf.Min(downDist, upDist));

            if (min == leftDist) px = from.xMin - 1;
            else if (min == rightDist) px = from.xMax;
            else if (min == downDist) py = from.yMin - 1;
            else py = from.yMax;
        }

        Vector2Int candidate = new Vector2Int(px, py);
        if (IsPointInsideAnyRoom(candidate, from))
        {
            Vector2 dir = (targetCenter - new Vector2(from.center.x, from.center.y)).normalized;
            Vector2Int step = new Vector2Int(Mathf.Clamp(Mathf.RoundToInt(Mathf.Sign(dir.x)), -1, 1),
                                             Mathf.Clamp(Mathf.RoundToInt(Mathf.Sign(dir.y)), -1, 1));
            candidate += step;
            candidate.x = Mathf.Clamp(candidate.x, 0, Width - 1);
            candidate.y = Mathf.Clamp(candidate.y, 0, Height - 1);
        }

        if (IsPointInsideAnyRoom(candidate, from) || !InBounds(candidate.x, candidate.y))
        {
            for (int r = 1; r <= 3; r++)
            {
                for (int dx = -r; dx <= r; dx++)
                    for (int dy = -r; dy <= r; dy++)
                    {
                        if (Mathf.Abs(dx) != r && Mathf.Abs(dy) != r) continue;
                        var t = new Vector2Int(candidate.x + dx, candidate.y + dy);
                        if (!InBounds(t.x, t.y)) continue;
                        if (!IsPointInsideAnyRoom(t, (Room)null))
                        {
                            return t;
                        }
                    }
            }
        }

        return candidate;
    }

    private bool IsPointInsideAnyRoom(Vector2Int pt, RectInt? allowInsideRoom)
    {
        foreach (var r in rooms)
        {
            if (allowInsideRoom.HasValue && r.rect.Equals(allowInsideRoom.Value)) continue;
            if (r.rect.Contains(pt)) return true;
        }
        return false;
    }

    private bool IsPointInsideAnyRoom(Vector2Int pt, Room ignoreRoom)
    {
        foreach (var r in rooms)
        {
            if (ignoreRoom != null && r == ignoreRoom) continue;
            if (r.rect.Contains(pt)) return true;
        }
        return false;
    }

    // If adjacency can't create tiles, do a guarded L-path: skip tiles that would lie inside rooms.
    private void AddFallbackCorridor(Room a, Room b)
    {
        var ar = a.rect;
        var br = b.rect;
        Vector2Int dA, dB;

        if (ar.xMax <= br.xMin && OverlapRange(ar.yMin, ar.yMax, br.yMin, br.yMax, out int y))
        {
            dA = new Vector2Int(ar.xMax - 1, y); dB = new Vector2Int(br.xMin, y);
        }
        else if (br.xMax <= ar.xMin && OverlapRange(ar.yMin, ar.yMax, br.yMin, br.yMax, out int y2))
        {
            dA = new Vector2Int(ar.xMin, y2); dB = new Vector2Int(br.xMax - 1, y2);
        }
        else if (ar.yMax <= br.yMin && OverlapRange(ar.xMin, ar.xMax, br.xMin, br.xMax, out int x))
        {
            dA = new Vector2Int(x, ar.yMax - 1); dB = new Vector2Int(x, br.yMin);
        }
        else if (br.yMax <= ar.yMin && OverlapRange(ar.xMin, ar.xMax, br.xMin, br.xMax, out int x2))
        {
            dA = new Vector2Int(x2, ar.yMin); dB = new Vector2Int(x2, br.yMax - 1);
        }
        else
        {
            dA = Vector2Int.RoundToInt(ar.center); dB = Vector2Int.RoundToInt(br.center);
        }

        var p = GuardedLPath(dA, dB, a, b);
        if (p != null && p.Count > 0)
        {
            doors.Add(dA); doors.Add(dB);
            corridors.Add(new Corridor(p));
        }
    }

    private List<Vector2Int> GuardedLPath(Vector2Int a, Vector2Int b, Room A, Room B)
    {
        var p = new List<Vector2Int>();
        bool first = Random.value > .5f;

        if (first)
        {
            for (int x = a.x; x != b.x; x += (int)Mathf.Sign(b.x - a.x))
            {
                var t = new Vector2Int(x, a.y);
                if (!IsPointInsideAnyRoom(t, A) && !IsPointInsideAnyRoom(t, B)) p.Add(t);
            }

            for (int y = a.y; y != b.y; y += (int)Mathf.Sign(b.y - a.y))
            {
                var t = new Vector2Int(b.x, y);
                if (!IsPointInsideAnyRoom(t, A) && !IsPointInsideAnyRoom(t, B)) p.Add(t);
            }
        }
        else
        {
            for (int y = a.y; y != b.y; y += (int)Mathf.Sign(b.y - a.y))
            {
                var t = new Vector2Int(a.x, y);
                if (!IsPointInsideAnyRoom(t, A) && !IsPointInsideAnyRoom(t, B)) p.Add(t);
            }

            for (int x = a.x; x != b.x; x += (int)Mathf.Sign(b.x - a.x))
            {
                var t = new Vector2Int(x, b.y);
                if (!IsPointInsideAnyRoom(t, A) && !IsPointInsideAnyRoom(t, B)) p.Add(t);
            }
        }

        p.Add(b);
        return p;
    }

    // ------------------- Validation / pruning / bookkeeping -------------------
    // Remove corridors that do not connect exactly two distinct rooms via their endpoints.
    private void ValidateAndPruneCorridors()
    {
        if (corridors == null || corridors.Count == 0) return;

        var kept = new List<Corridor>();

        foreach (var c in corridors)
        {
            if (c == null || c.tiles == null || c.tiles.Count == 0) continue;

            Vector2Int a = c.tiles[0];
            Vector2Int b = c.tiles[c.tiles.Count - 1];

            Room roomA = RoomTouchedByEndpoint(a);
            Room roomB = RoomTouchedByEndpoint(b);

            if (roomA != null && roomB != null && !ReferenceEquals(roomA, roomB))
            {
                // record room refs for future graph operations
                c.roomA = roomA;
                c.roomB = roomB;
                kept.Add(c);
            }
            else
            {
                // optional: uncomment to debug pruned corridors
                // Debug.Log($"Pruned corridor endpoints {a}→{b} touched {roomA?.id.ToString() ?? "null"} & {roomB?.id.ToString() ?? "null"}");
            }
        }

        corridors = kept;
    }

    // returns the Room that the given corridor endpoint tile is adjacent to (tile is outside room rect)
    private Room RoomTouchedByEndpoint(Vector2Int endpoint)
    {
        foreach (var r in rooms)
        {
            var up = new Vector2Int(endpoint.x, endpoint.y + 1);
            var down = new Vector2Int(endpoint.x, endpoint.y - 1);
            var left = new Vector2Int(endpoint.x - 1, endpoint.y);
            var right = new Vector2Int(endpoint.x + 1, endpoint.y);

            if (r.rect.Contains(up) || r.rect.Contains(down) || r.rect.Contains(left) || r.rect.Contains(right))
                return r;
        }
        return null;
    }

    // Rebuild doors list (two endpoints per corridor) and intersections (tiles used by multiple corridors)
    private void RebuildDoorsAndIntersections()
    {
        doors.Clear();
        intersections.Clear();

        var tileCount = new Dictionary<long, int>();

        foreach (var c in corridors)
        {
            if (c == null || c.tiles == null || c.tiles.Count == 0) continue;

            doors.Add(c.tiles[0]);
            doors.Add(c.tiles[c.tiles.Count - 1]);

            foreach (var t in c.tiles)
            {
                long key = ((long)t.x << 32) | (uint)t.y;
                if (tileCount.ContainsKey(key)) tileCount[key] = tileCount[key] + 1;
                else tileCount[key] = 1;
            }
        }

        foreach (var kv in tileCount)
        {
            if (kv.Value > 1)
            {
                int x = (int)(kv.Key >> 32);
                int y = (int)(kv.Key & 0xffffffff);
                intersections.Add(new Vector2Int(x, y));
            }
        }
    }

    // ------------------- MST over rooms using corridors as candidate edges (Kruskal) -------------------
    private int[] ufParent;
    private void InitUnionFind(int count)
    {
        ufParent = new int[count];
        for (int i = 0; i < count; i++) ufParent[i] = i;
    }
    private int UFFind(int x)
    {
        if (ufParent[x] != x) ufParent[x] = UFFind(ufParent[x]);
        return ufParent[x];
    }
    private void UFUnion(int a, int b)
    {
        int pa = UFFind(a);
        int pb = UFFind(b);
        if (pa != pb) ufParent[pb] = pa;
    }

    // Keep minimal set of corridors that connects all rooms (rooms are nodes)
    private void ApplyMSTToCorridors()
    {
        if (rooms == null || rooms.Count == 0) return;
        InitUnionFind(rooms.Count);

        var kept = new List<Corridor>();

        // Sort edges by distance between room centers (shorter first) to bias toward local connections
        corridors.Sort((c1, c2) =>
        {
            float d1 = Vector2.Distance(c1.roomA.rect.center, c1.roomB.rect.center);
            float d2 = Vector2.Distance(c2.roomA.rect.center, c2.roomB.rect.center);
            return d1.CompareTo(d2);
        });

        foreach (var c in corridors)
        {
            if (c == null || c.roomA == null || c.roomB == null) continue;
            int ia = rooms.IndexOf(c.roomA);
            int ib = rooms.IndexOf(c.roomB);
            if (ia < 0 || ib < 0) continue;

            if (UFFind(ia) != UFFind(ib))
            {
                kept.Add(c);
                UFUnion(ia, ib);
            }
            // else this corridor would create a loop and is pruned
        }

        corridors = kept;
    }

    // mark corridor tiles as walkable for future BFS
    private void ApplyCorridorsToGrid()
    {
        if (walkable == null) return;
        foreach (var c in corridors)
        {
            if (c?.tiles == null) continue;
            foreach (var t in c.tiles)
            {
                if (InBounds(t.x, t.y))
                    walkable[t.x, t.y] = true;
            }
        }
    }

    // ------------------- Utilities -------------------
    bool OverlapRange(int aMin, int aMax, int bMin, int bMax, out int v)
    {
        int min = Mathf.Max(aMin, bMin);
        int max = Mathf.Min(aMax - 1, bMax - 1);

        v = (max < min) ? ((aMin + aMax) / 2) : Random.Range(min, max + 1);

        return true;
    }

    List<Vector2Int> Path(Vector2Int a, Vector2Int b)
    {
        List<Vector2Int> p = new List<Vector2Int>();
        bool first = Random.value > .5f;

        if (first)
        {
            for (int x = a.x; x != b.x; x += (int)Mathf.Sign(b.x - a.x))
                p.Add(new Vector2Int(x, a.y));
            for (int y = a.y; y != b.y; y += (int)Mathf.Sign(b.y - a.y))
                p.Add(new Vector2Int(b.x, y));
        }
        else
        {
            for (int y = a.y; y != b.y; y += (int)Mathf.Sign(b.y - a.y))
                p.Add(new Vector2Int(a.x, y));
            for (int x = a.x; x != b.x; x += (int)Mathf.Sign(b.x - a.x))
                p.Add(new Vector2Int(x, b.y));
        }

        p.Add(b);
        return p;
    }

    private Vector2Int EnsureDoorIsOutsideAndInBounds(Vector2Int door, Room room)
    {
        door.x = Mathf.Clamp(door.x, 0, Width - 1);
        door.y = Mathf.Clamp(door.y, 0, Height - 1);

        if (!IsPointInsideAnyRoom(door, (Room)null)) return door;

        Vector2 dir = (new Vector2(door.x, door.y) - new Vector2(room.rect.center.x, room.rect.center.y)).normalized;
        Vector2Int step = new Vector2Int(Mathf.Clamp(Mathf.RoundToInt(Mathf.Sign(dir.x)), -1, 1),
                                         Mathf.Clamp(Mathf.RoundToInt(Mathf.Sign(dir.y)), -1, 1));

        for (int i = 1; i <= 4; i++)
        {
            var candidate = new Vector2Int(door.x + step.x * i, door.y + step.y * i);
            if (!InBounds(candidate.x, candidate.y)) continue;
            if (!IsPointInsideAnyRoom(candidate, (Room)null)) return candidate;
        }

        for (int r = 1; r <= 4; r++)
        {
            for (int dx = -r; dx <= r; dx++)
                for (int dy = -r; dy <= r; dy++)
                {
                    if (Mathf.Abs(dx) != r && Mathf.Abs(dy) != r) continue;
                    var candidate = new Vector2Int(door.x + dx, door.y + dy);
                    if (!InBounds(candidate.x, candidate.y)) continue;
                    if (!IsPointInsideAnyRoom(candidate, (Room)null)) return candidate;
                }
        }

        door.x = Mathf.Clamp(door.x, 0, Width - 1);
        door.y = Mathf.Clamp(door.y, 0, Height - 1);
        return door;
    }

    private Vector2Int SnapDoorToNearestTile(Vector2Int desired, List<Vector2Int> tiles)
    {
        if (tiles == null || tiles.Count == 0) return desired;
        int best = int.MaxValue;
        Vector2Int pick = tiles[0];
        foreach (var t in tiles)
        {
            int dist = Mathf.Abs(t.x - desired.x) + Mathf.Abs(t.y - desired.y);
            if (dist < best)
            {
                best = dist;
                pick = t;
            }
        }
        return pick;
    }

    // ------------------- Fallback MST connector -------------------
    private void ConnectNeighborsMST_Fallback()
    {
        if (leaves == null || leaves.Count == 0) return;

        HashSet<Partition> visited = new HashSet<Partition>();
        Partition start = leaves[Random.Range(0, leaves.Count)];
        visited.Add(start);

        while (visited.Count < leaves.Count)
        {
            float best = float.MaxValue;
            Partition bestA = null;
            Partition bestB = null;

            foreach (var v in visited)
            {
                if (v == null || v.neighbors == null) continue;
                foreach (var n in v.neighbors)
                {
                    if (n == null || visited.Contains(n)) continue;
                    if (v.room == null || n.room == null) continue;

                    float d = Vector2.Distance(v.room.rect.center, n.room.rect.center);
                    if (d < best)
                    {
                        best = d;
                        bestA = v;
                        bestB = n;
                    }
                }
            }

            if (bestA == null || bestB == null) break;

            // prefer adjacency corridor if possible
            HashSet<string> dummy = new HashSet<string>();
            if (!CreateBoundaryCorridor(bestA, bestB, dummy))
            {
                SafeConnectRooms(bestA.room, bestB.room);
            }

            visited.Add(bestB);
        }
    }

    // ------------------- Debug / Graph print -------------------
    private void DebugRoomGraph()
    {
        var sb = new StringBuilder();
        sb.AppendLine("=== ROOM GRAPH ===");
        for (int i = 0; i < rooms.Count; i++)
        {
            var r = rooms[i];
            var connects = new List<int>();
            for (int j = 0; j < rooms.Count; j++)
            {
                if (i == j) continue;
                if (AreRoomsConnected(rooms[i], rooms[j])) connects.Add(j);
            }
            sb.Append($"Room {r.id} -> ");
            if (connects.Count == 0) sb.Append("no direct connections");
            else sb.Append(string.Join(", ", connects));
            sb.AppendLine();
        }
        Debug.Log(sb.ToString());
    }

    private bool AreRoomsConnected(Room a, Room b)
    {
        foreach (var c in corridors)
        {
            if (c.tiles == null || c.tiles.Count == 0) continue;
            var t0 = c.tiles[0];
            var t1 = c.tiles[c.tiles.Count - 1];
            var r0 = RoomTouchedByEndpoint(t0);
            var r1 = RoomTouchedByEndpoint(t1);
            if (r0 == null || r1 == null) continue;
            if ((ReferenceEquals(r0, a) && ReferenceEquals(r1, b)) || (ReferenceEquals(r1, a) && ReferenceEquals(r0, b)))
                return true;
        }
        return false;
    }

    // ------------------- Gizmos / debug drawing -------------------
    void OnDrawGizmos()
    {
        if (root == null) return;

        // Partitions (wire)
        Gizmos.color = new Color(1, 1, 1, .06f);
        DrawBounds(root);

        // Rooms (floor fill)
        Gizmos.color = new Color(0.6f, 0.8f, 1f, 0.12f);
        foreach (var r in rooms)
            Gizmos.DrawCube(new Vector3(r.rect.center.x, 0, r.rect.center.y),
                            new Vector3(r.rect.width, .01f, r.rect.height));

        // Rooms (wireframe)
        Gizmos.color = Color.green;
        foreach (var r in rooms)
            Gizmos.DrawWireCube(new Vector3(r.rect.center.x, 0.02f, r.rect.center.y),
                                new Vector3(r.rect.width, .03f, r.rect.height));

        // Corridors
        Gizmos.color = Color.white;
        foreach (var c in corridors)
        {
            if (c?.tiles == null) continue;
            foreach (var t in c.tiles)
                Gizmos.DrawCube(new Vector3(t.x + .5f, 0, t.y + .5f), new Vector3(.9f, .05f, .9f));
        }

        // Doors
        Gizmos.color = new Color(.4f, .2f, 0);
        foreach (var d in doors)
            Gizmos.DrawCube(new Vector3(d.x + .5f, 0.02f, d.y + .5f), new Vector3(.7f, .08f, .7f));

        // Intersections
        Gizmos.color = Color.yellow;
        foreach (var it in intersections)
            Gizmos.DrawCube(new Vector3(it.x + .5f, 0.03f, it.y + .5f), new Vector3(.5f, .12f, .5f));
    }

    void DrawBounds(Partition p)
    {
        if (p == null) return;

        Gizmos.DrawWireCube(new Vector3(p.rect.center.x, 0, p.rect.center.y),
                            new Vector3(p.rect.width, .03f, p.rect.height));

        if (p.left != null) DrawBounds(p.left);
        if (p.right != null) DrawBounds(p.right);
    }
}

// ------------------- Simple data classes -------------------
public class Partition
{
    public RectInt rect;
    public Partition left;
    public Partition right;
    public Room room;
    public List<Partition> neighbors;

    public Partition(RectInt r)
    {
        rect = r;
        neighbors = new List<Partition>();
    }
}

public class Room
{
    public RectInt rect;
    public int id;
    public Room(RectInt r, int id) { rect = r; this.id = id; }
}

public class Corridor
{
    public List<Vector2Int> tiles;
    public Room roomA;
    public Room roomB;
    public Corridor(List<Vector2Int> t) { tiles = t; }
}