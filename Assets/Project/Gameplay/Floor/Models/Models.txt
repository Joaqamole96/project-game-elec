// CorridorModel.cs
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Represents a corridor connecting two rooms in the dungeon.
/// Contains pathfinding data and door positions.
/// </summary>
public class CorridorModel
{
    /// <summary>List of tile positions that make up the corridor path.</summary>
    public List<Vector2Int> Tiles { get; private set; }
    
    /// <summary>Starting room connected by this corridor.</summary>
    public RoomModel StartRoom { get; private set; }
    
    /// <summary>Ending room connected by this corridor.</summary>
    public RoomModel EndRoom { get; private set; }
    
    /// <summary>Door position at the start room connection.</summary>
    public Vector2Int StartDoorPosition { get; private set; }
    
    /// <summary>Door position at the end room connection.</summary>
    public Vector2Int EndDoorPosition { get; private set; }
    
    /// <summary>Door model for the start room connection (created on demand).</summary>
    public DoorModel StartDoor { get; private set; }
    
    /// <summary>Door model for the end room connection (created on demand).</summary>
    public DoorModel EndDoor { get; private set; }
    
    /// <summary>Length of the corridor in tiles.</summary>
    public float Length => Tiles?.Count ?? 0f;
    
    /// <summary>Center position of the corridor.</summary>
    public Vector2Int Center => Tiles?.Count > 0 ? Tiles[Tiles.Count / 2] : Vector2Int.zero;

    public CorridorModel(List<Vector2Int> tiles, RoomModel startRoom, RoomModel endRoom, 
                        Vector2Int startDoorPos, Vector2Int endDoorPos)
    {
        Tiles = tiles ?? new List<Vector2Int>();
        StartRoom = startRoom;
        EndRoom = endRoom;
        StartDoorPosition = startDoorPos;
        EndDoorPosition = endDoorPos;

        ConnectRooms();
    }
    
    private void ConnectRooms()
    {
        if (StartRoom != null && EndRoom != null && StartRoom != EndRoom)
        {
            StartRoom.AddConnectedRoom(EndRoom);
            EndRoom.AddConnectedRoom(StartRoom);
        }
    }
    
    /// <summary>
    /// Gets or creates the door model for the start room connection.
    /// </summary>
    public DoorModel GetStartDoor()
    {
        StartDoor ??= new DoorModel(StartDoorPosition, DoorType.Wood);
        return StartDoor;
    }
    
    /// <summary>
    /// Gets or creates the door model for the end room connection.
    /// </summary>
    public DoorModel GetEndDoor()
    {
        EndDoor ??= new DoorModel(EndDoorPosition, DoorType.Wood);
        return EndDoor;
    }

    /// <summary>
    /// Checks if this corridor contains the specified position.
    /// </summary>
    public bool ContainsPosition(Vector2Int position) => Tiles.Contains(position);

    /// <summary>
    /// Checks if this corridor connects the specified room.
    /// </summary>
    public bool ConnectsRoom(RoomModel room)
    {
        return StartRoom == room || EndRoom == room;
    }

    /// <summary>
    /// Gets the other room connected by this corridor.
    /// </summary>
    public RoomModel GetOtherRoom(RoomModel room)
    {
        if (room == StartRoom) return EndRoom;
        if (room == EndRoom) return StartRoom;
        return null;
    }
}

// DoorModel.cs
using UnityEngine;

/// <summary>
/// Represents a door between rooms or corridors with state and interaction properties.
/// </summary>
public class DoorModel
{
    /// <summary>Grid position of the door.</summary>
    public Vector2Int Position { get; private set; }
    
    /// <summary>Type of door (affects appearance and properties).</summary>
    public DoorType Type { get; private set; }
    
    /// <summary>Current state of the door.</summary>
    public DoorState State { get; private set; }
    
    /// <summary>Key required to open this door (if locked).</summary>
    public KeyType RequiredKey { get; private set; }
    
    /// <summary>World position of the door for gameplay.</summary>
    public Vector3 WorldPosition => new Vector3(Position.x + 0.5f, 0f, Position.y + 0.5f);

    public DoorModel(Vector2Int position, DoorType type = DoorType.Wood)
    {
        Position = position;
        Type = type;
        State = DoorState.Closed;
        RequiredKey = KeyType.None;
    }
    
    /// <summary>
    /// Checks if the door can be opened with the given key.
    /// </summary>
    public bool CanOpen(KeyType key = KeyType.None)
    {
        return State != DoorState.Locked || (State == DoorState.Locked && key == RequiredKey);
    }
    
    /// <summary>
    /// Attempts to open the door. Returns true if successful.
    /// </summary>
    public bool TryOpen(KeyType key = KeyType.None)
    {
        if (!CanOpen(key)) return false;
        
        State = DoorState.Open;
        return true;
    }
    
    /// <summary>
    /// Closes the door if it's not locked.
    /// </summary>
    public void Close()
    {
        if (State != DoorState.Locked)
            State = DoorState.Closed;
    }
    
    /// <summary>
    /// Locks the door with the specified key type.
    /// </summary>
    public void Lock(KeyType keyType)
    {
        State = DoorState.Locked;
        RequiredKey = keyType;
    }
    
    /// <summary>
    /// Unlocks the door if the correct key is provided.
    /// </summary>
    public bool TryUnlock(KeyType key)
    {
        if (State == DoorState.Locked && key == RequiredKey)
        {
            State = DoorState.Closed;
            RequiredKey = KeyType.None;
            return true;
        }
        return false;
    }
    
    /// <summary>
    /// Forces the door open regardless of lock state (for debugging/cheats).
    /// </summary>
    public void ForceOpen()
    {
        State = DoorState.Open;
    }
    
    /// <summary>
    /// Checks if the door is currently blocking pathfinding.
    /// </summary>
    public bool IsBlocking => State == DoorState.Closed || State == DoorState.Locked;
}

/// <summary>
/// Types of doors with different properties and appearances.
/// </summary>
public enum DoorType
{
    Wood,
    Metal,
    Secret,
    Boss
}

/// <summary>
/// Possible states for a door.
/// </summary>
public enum DoorState
{
    Open,
    Closed,
    Locked,
    Broken
}

/// <summary>
/// Types of keys that can unlock doors.
/// </summary>
public enum KeyType
{
    None,
    Key,
    MasterKey,
    BossKey
}

// FloorModel.cs
using UnityEngine;

/// <summary>
/// Represents an individual walkable floor tile with gameplay properties.
/// Created sparingly for tiles that need special gameplay functionality.
/// </summary>
public class FloorModel
{
    /// <summary>Grid position of the floor tile.</summary>
    public Vector2Int Position { get; private set; }
    
    /// <summary>Type of room this floor belongs to.</summary>
    public RoomType RoomType { get; private set; }
    
    /// <summary>Material/visual type of the floor.</summary>
    public MaterialType Material { get; private set; }
    
    /// <summary>World position for gameplay objects.</summary>
    public Vector3 WorldPosition => new Vector3(Position.x + 0.5f, 0f, Position.y + 0.5f);
    
    /// <summary>Whether this floor tile has any special gameplay properties.</summary>
    public bool HasSpecialProperties => Material != MaterialType.Default;

    public FloorModel(Vector2Int position, RoomType roomType = RoomType.Combat)
    {
        Position = position;
        RoomType = roomType;
        Material = MaterialType.Default;
    }

    /// <summary>
    /// Sets the material type for this floor tile.
    /// </summary>
    public void SetMaterial(MaterialType material)
    {
        Material = material;
    }

    /// <summary>
    /// Checks if this floor tile is traversable by the player.
    /// </summary>
    public bool IsTraversable => Material != MaterialType.Impassable;

    /// <summary>
    /// Gets the movement cost for pathfinding over this tile.
    /// </summary>
    public float GetMovementCost()
    {
        return Material switch
        {
            MaterialType.Default => 1.0f,
            MaterialType.Cracked => 1.2f,
            MaterialType.Mossy => 1.5f,
            MaterialType.Bloody => 1.3f,
            MaterialType.Ice => 0.8f,
            _ => 1.0f
        };
    }
}

/// <summary>
/// Types of floor materials with different gameplay properties.
/// </summary>
public enum MaterialType
{
    Default,
    Cracked,
    Mossy,
    Bloody,
    Ice,
    Impassable
}

// LevelModel.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// Represents the complete dungeon level with rooms, corridors, and spatial data.
/// Optimized for both rendering and gameplay access patterns.
/// </summary>
public class LevelModel
{
    /// <summary>All rooms in the level.</summary>
    public List<RoomModel> Rooms { get; set; } = new List<RoomModel>();
    
    /// <summary>All corridors connecting rooms.</summary>
    public List<CorridorModel> Corridors { get; set; } = new List<CorridorModel>();
    
    // Rendering data
    /// <summary>All floor tile positions for rendering.</summary>
    public HashSet<Vector2Int> AllFloorTiles { get; set; } = new HashSet<Vector2Int>();
    
    /// <summary>All wall tile positions for rendering.</summary>
    public HashSet<Vector2Int> AllWallTiles { get; set; } = new HashSet<Vector2Int>();
    
    /// <summary>All door tile positions for rendering.</summary>
    public HashSet<Vector2Int> AllDoorTiles { get; set; } = new HashSet<Vector2Int>();
    
    /// <summary>Wall types for each wall position.</summary>
    public Dictionary<Vector2Int, WallType> WallTypes { get; set; } = new Dictionary<Vector2Int, WallType>();
    
    // Gameplay objects (created on demand)
    /// <summary>Gameplay floor models for special tiles only.</summary>
    public Dictionary<Vector2Int, FloorModel> GameplayFloors { get; private set; } = new Dictionary<Vector2Int, FloorModel>();
    
    /// <summary>Gameplay wall models for interactive walls only.</summary>
    public Dictionary<Vector2Int, WallModel> GameplayWalls { get; private set; } = new Dictionary<Vector2Int, WallModel>();
    
    /// <summary>All door models for gameplay interactions.</summary>
    public Dictionary<Vector2Int, DoorModel> GameplayDoors { get; private set; } = new Dictionary<Vector2Int, DoorModel>();
    
    // Spatial data for efficient queries
    /// <summary>Overall bounds of the entire level.</summary>
    public BoundsInt OverallBounds { get; private set; }
    
    private Dictionary<Vector2Int, RoomModel> _tileToRoomMap;
    private Dictionary<Vector2Int, CorridorModel> _tileToCorridorMap;
    private Dictionary<RoomModel, List<RoomModel>> _roomGraph;
    private bool _isInitialized = false;

    /// <summary>
    /// Initializes spatial data structures for efficient querying.
    /// </summary>
    public void InitializeSpatialData()
    {
        if (_isInitialized) return;

        CalculateOverallBounds();
        BuildTileMaps();
        BuildRoomGraph();
        InitializeGameplayObjects();
        
        _isInitialized = true;
        
        Debug.Log($"Level spatial data initialized: {Rooms.Count} rooms, {Corridors.Count} corridors, {AllFloorTiles.Count} floor tiles");
    }

    private void CalculateOverallBounds()
    {
        if (Rooms.Count == 0) 
        {
            OverallBounds = new BoundsInt(0, 0, 0, 0, 0, 0);
            return;
        }
        
        int minX = Rooms.Min(r => r.Bounds.xMin);
        int maxX = Rooms.Max(r => r.Bounds.xMax);
        int minY = Rooms.Min(r => r.Bounds.yMin);
        int maxY = Rooms.Max(r => r.Bounds.yMax);
        
        OverallBounds = new BoundsInt(minX, minY, 0, maxX - minX, maxY - minY, 1);
    }
    
    private void BuildTileMaps()
    {
        _tileToRoomMap = new Dictionary<Vector2Int, RoomModel>();
        _tileToCorridorMap = new Dictionary<Vector2Int, CorridorModel>();
        
        BuildRoomTileMap();
        BuildCorridorTileMap();
    }

    private void BuildRoomTileMap()
    {
        foreach (var room in Rooms)
        {
            foreach (var tile in room.GetFloorTiles())
            {
                _tileToRoomMap[tile] = room;
            }
        }
    }

    private void BuildCorridorTileMap()
    {
        foreach (var corridor in Corridors.Where(c => c?.Tiles != null))
        {
            foreach (var tile in corridor.Tiles)
            {
                _tileToCorridorMap[tile] = corridor;
                // Mark corridor tiles as not belonging to any room
                if (!_tileToRoomMap.ContainsKey(tile))
                {
                    _tileToRoomMap[tile] = null;
                }
            }
        }
    }
    
    private void BuildRoomGraph()
    {
        _roomGraph = new Dictionary<RoomModel, List<RoomModel>>();
        
        // Initialize graph with all rooms
        foreach (var room in Rooms)
        {
            _roomGraph[room] = new List<RoomModel>();
        }
        
        // Add connections from corridors
        foreach (var corridor in Corridors.Where(IsValidCorridor))
        {
            AddRoomConnection(corridor.StartRoom, corridor.EndRoom);
            AddRoomConnection(corridor.EndRoom, corridor.StartRoom);
        }
    }

    private bool IsValidCorridor(CorridorModel corridor)
    {
        return corridor?.StartRoom != null && corridor?.EndRoom != null;
    }

    private void AddRoomConnection(RoomModel roomA, RoomModel roomB)
    {
        if (_roomGraph.ContainsKey(roomA) && !_roomGraph[roomA].Contains(roomB))
        {
            _roomGraph[roomA].Add(roomB);
        }
    }
    
    private void InitializeGameplayObjects()
    {
        InitializeDoors();
        // FloorModel and WallModel are created on demand to save memory
    }

    private void InitializeDoors()
    {
        foreach (var doorPos in AllDoorTiles)
        {
            GameplayDoors[doorPos] = new DoorModel(doorPos);
        }
    }

    // Public API for gameplay systems
    
    /// <summary>
    /// Gets the room at the specified position, or null if not in a room.
    /// </summary>
    public RoomModel GetRoomAtPosition(Vector2Int position)
    {
        if (!_isInitialized) InitializeSpatialData();
        _tileToRoomMap.TryGetValue(position, out var room);
        return room;
    }
    
    /// <summary>
    /// Gets the corridor at the specified position, or null if not in a corridor.
    /// </summary>
    public CorridorModel GetCorridorAtPosition(Vector2Int position)
    {
        if (!_isInitialized) InitializeSpatialData();
        _tileToCorridorMap.TryGetValue(position, out var corridor);
        return corridor;
    }

    /// <summary>
    /// Gets the room graph for pathfinding and AI.
    /// </summary>
    public Dictionary<RoomModel, List<RoomModel>> RoomGraph 
    { 
        get 
        {
            if (!_isInitialized) InitializeSpatialData();
            return _roomGraph;
        } 
    }

    // Tile type queries
    
    /// <summary>
    /// Checks if the position is a walkable floor tile.
    /// </summary>
    public bool IsFloorTile(Vector2Int position) => AllFloorTiles.Contains(position);
    
    /// <summary>
    /// Checks if the position is a wall tile.
    /// </summary>
    public bool IsWallTile(Vector2Int position) => AllWallTiles.Contains(position);
    
    /// <summary>
    /// Checks if the position is a door tile.
    /// </summary>
    public bool IsDoorTile(Vector2Int position) => AllDoorTiles.Contains(position);
    
    /// <summary>
    /// Checks if the position is traversable by the player.
    /// </summary>
    public bool IsTraversable(Vector2Int position) => IsFloorTile(position) || IsDoorTile(position);

    // Gameplay object management (lazy initialization)
    
    /// <summary>
    /// Gets or creates a FloorModel for tiles that need special gameplay.
    /// </summary>
    public FloorModel GetOrCreateGameplayFloor(Vector2Int position)
    {
        if (!GameplayFloors.TryGetValue(position, out var floor))
        {
            var room = GetRoomAtPosition(position);
            floor = new FloorModel(position, room?.Type ?? RoomType.Combat);
            GameplayFloors[position] = floor;
        }
        return floor;
    }
    
    /// <summary>
    /// Gets or creates a WallModel for walls that need interaction.
    /// </summary>
    public WallModel GetOrCreateGameplayWall(Vector2Int position)
    {
        if (!GameplayWalls.TryGetValue(position, out var wall))
        {
            var wallType = WallTypes.ContainsKey(position) ? WallTypes[position] : WallType.North;
            wall = new WallModel(position, wallType, isDestructible: false);
            GameplayWalls[position] = wall;
        }
        return wall;
    }
    
    /// <summary>
    /// Gets the door model at the specified position.
    /// </summary>
    public DoorModel GetDoorAtPosition(Vector2Int position)
    {
        GameplayDoors.TryGetValue(position, out var door);
        return door;
    }

    /// <summary>
    /// Gets all rooms of the specified type.
    /// </summary>
    public List<RoomModel> GetRoomsOfType(RoomType roomType)
    {
        return Rooms.Where(room => room.Type == roomType).ToList();
    }

    /// <summary>
    /// Gets the entrance room for player spawning.
    /// </summary>
    public RoomModel GetEntranceRoom()
    {
        return Rooms.FirstOrDefault(room => room.Type == RoomType.Entrance);
    }

    /// <summary>
    /// Gets the exit room for level progression.
    /// </summary>
    public RoomModel GetExitRoom()
    {
        return Rooms.FirstOrDefault(room => room.Type == RoomType.Exit);
    }
}

/// <summary>
/// Serialized data for saving/loading floor state.
/// </summary>
[Serializable]
public class FloorSaveData
{
    public int Seed;
    public int FloorLevel;
    public List<RoomSaveData> Rooms;
    public Vector2Int PlayerPosition;
    
    // Player data would be in a separate PlayerSaveData class
    // public int PlayerHealth;
    // public int Gold;
}

// PartitionModel.cs
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Represents a partition in the Binary Space Partitioning (BSP) tree.
/// Used during dungeon generation to divide space into rooms.
/// </summary>
public class PartitionModel
{
    /// <summary>Bounds of this partition in grid coordinates.</summary>
    public RectInt Bounds { get; private set; }
    
    /// <summary>Left child partition (null if leaf node).</summary>
    public PartitionModel LeftChild { get; set; }
    
    /// <summary>Right child partition (null if leaf node).</summary>
    public PartitionModel RightChild { get; set; }
    
    /// <summary>Room generated within this partition (null if not a leaf).</summary>
    public RoomModel Room { get; set; }
    
    /// <summary>Adjacent partitions for corridor generation.</summary>
    public List<PartitionModel> Neighbors { get; private set; }
    
    /// <summary>Whether this is a leaf node (no children).</summary>
    public bool IsLeaf => LeftChild == null && RightChild == null;
    
    /// <summary>Center point of the partition.</summary>
    public Vector2Int Center => new Vector2Int(Bounds.x + Bounds.width / 2, Bounds.y + Bounds.height / 2);

    public PartitionModel(RectInt bounds)
    {
        Bounds = bounds;
        Neighbors = new List<PartitionModel>();
    }

    /// <summary>
    /// Gets all leaf partitions in this subtree.
    /// </summary>
    public List<PartitionModel> GetLeafPartitions()
    {
        var leaves = new List<PartitionModel>();
        CollectLeaves(this, leaves);
        return leaves;
    }

    private void CollectLeaves(PartitionModel partition, List<PartitionModel> leaves)
    {
        if (partition == null) return;
        
        if (partition.IsLeaf)
        {
            leaves.Add(partition);
        }
        else
        {
            CollectLeaves(partition.LeftChild, leaves);
            CollectLeaves(partition.RightChild, leaves);
        }
    }

    /// <summary>
    /// Checks if this partition can contain a room of the specified minimum size.
    /// </summary>
    public bool CanContainRoom(int minRoomSize)
    {
        return Bounds.width >= minRoomSize && Bounds.height >= minRoomSize;
    }

    /// <summary>
    /// Gets the area of this partition in tiles.
    /// </summary>
    public int Area => Bounds.width * Bounds.height;

    /// <summary>
    /// Checks if this partition overlaps with another partition.
    /// </summary>
    public bool Overlaps(PartitionModel other)
    {
        return Bounds.Overlaps(other.Bounds);
    }

    /// <summary>
    /// Checks if this partition touches another partition on any edge.
    /// </summary>
    public bool Touches(PartitionModel other)
    {
        return Bounds.xMax == other.Bounds.xMin || Bounds.xMin == other.Bounds.xMax ||
               Bounds.yMax == other.Bounds.yMin || Bounds.yMin == other.Bounds.yMax;
    }
}

// RoomModel.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// Represents a room in the dungeon with bounds, type, and gameplay state.
/// </summary>
public class RoomModel
{
    /// <summary>Bounds of the room in grid coordinates.</summary>
    public RectInt Bounds { get; private set; }
    
    /// <summary>Unique identifier for this room.</summary>
    public int ID { get; private set; }
    
    /// <summary>Rooms connected to this room via corridors.</summary>
    public List<RoomModel> ConnectedRooms { get; private set; }
    
    /// <summary>Type and purpose of this room.</summary>
    public RoomType Type { get; set; }
    
    /// <summary>Access state of the room.</summary>
    public RoomAccess State { get; set; }
    
    /// <summary>Distance from entrance room for progression.</summary>
    public int DistanceFromEntrance { get; set; }
    
    /// <summary>Whether the room has been revealed to the player.</summary>
    public bool IsRevealed { get; set; }
    
    /// <summary>Whether the room has been cleared of enemies.</summary>
    public bool IsCleared { get; set; }
    
    /// <summary>Positions for spawning enemies or objects.</summary>
    public List<Vector2Int> SpawnPositions { get; private set; }
    
    /// <summary>Door at the room entrance (if any).</summary>
    public DoorModel EntranceDoor { get; set; }
    
    /// <summary>Door at the room exit (if any).</summary>
    public DoorModel ExitDoor { get; set; }
    
    /// <summary>Center point of the room.</summary>
    public Vector2Int Center => new Vector2Int(
        (Bounds.xMin + Bounds.xMax) / 2,
        (Bounds.yMin + Bounds.yMax) / 2
    );
    
    /// <summary>Area of the room in tiles.</summary>
    public int Area => Bounds.width * Bounds.height;

    public RoomModel(RectInt bounds, int id, RoomType type)
    {
        Bounds = bounds;
        ID = id;
        ConnectedRooms = new List<RoomModel>();
        Type = type;
        State = GetDefaultStateForType(type);
        IsRevealed = type == RoomType.Entrance;
        IsCleared = type != RoomType.Combat && type != RoomType.Boss;
        SpawnPositions = new List<Vector2Int>();
    }

    /// <summary>
    /// Enumerates all floor tile positions within the room (excluding walls).
    /// </summary>
    public IEnumerable<Vector2Int> GetFloorTiles()
    {
        // Ensure we have valid bounds that can contain floor tiles
        if (Bounds.width < 3 || Bounds.height < 3)
        {
            Debug.LogWarning($"Room {ID} bounds too small for floor tiles: {Bounds}");
            yield break;
        }

        for (int x = Bounds.xMin + 1; x < Bounds.xMax - 1; x++)
        {
            for (int y = Bounds.yMin + 1; y < Bounds.yMax - 1; y++)
            {
                yield return new Vector2Int(x, y);
            }
        }
    }

    /// <summary>
    /// Enumerates all wall tile positions around the room perimeter.
    /// </summary>
    public IEnumerable<Vector2Int> GetWallPerimeter()
    {
        // Top wall
        for (int x = Bounds.xMin; x < Bounds.xMax; x++)
            yield return new Vector2Int(x, Bounds.yMax - 1);
        
        // Bottom wall
        for (int x = Bounds.xMin; x < Bounds.xMax; x++)
            yield return new Vector2Int(x, Bounds.yMin);
        
        // Right wall
        for (int y = Bounds.yMin; y < Bounds.yMax; y++)
            yield return new Vector2Int(Bounds.xMax - 1, y);
        
        // Left wall
        for (int y = Bounds.yMin; y < Bounds.yMax; y++)
            yield return new Vector2Int(Bounds.xMin, y);
    }

    /// <summary>
    /// Checks if the position is within the room bounds.
    /// </summary>
    public bool ContainsPosition(Vector2Int position)
    {
        return position.x >= Bounds.xMin &&
               position.x < Bounds.xMax &&
               position.y >= Bounds.yMin &&
               position.y < Bounds.yMax;
    }

    /// <summary>
    /// Enumerates inner tiles with optional padding from walls.
    /// </summary>
    public IEnumerable<Vector2Int> GetInnerTiles(int padding = 1)
    {
        for (int x = Bounds.xMin + padding; x < Bounds.xMax - padding; x++)
            for (int y = Bounds.yMin + padding; y < Bounds.yMax - padding; y++)
                yield return new Vector2Int(x, y);
    }
    
    /// <summary>
    /// Adds a connected room if not already present.
    /// </summary>
    public void AddConnectedRoom(RoomModel room)
    {
        if (room != null && room != this && !ConnectedRooms.Contains(room))
        {
            ConnectedRooms.Add(room);
        }
    }

    /// <summary>
    /// Checks if this room is connected to the specified room.
    /// </summary>
    public bool IsConnectedTo(RoomModel room)
    {
        return ConnectedRooms.Contains(room);
    }

    /// <summary>
    /// Generates spawn positions within the room with proper spacing.
    /// </summary>
    public void GenerateSpawnPositions(int count, int padding = 2)
    {
        var innerTiles = GetInnerTiles(padding).ToList();
        if (innerTiles.Count == 0) return;
        
        SpawnPositions.Clear();
        var usedPositions = new HashSet<Vector2Int>();
        
        for (int i = 0; i < Mathf.Min(count, innerTiles.Count); i++)
        {
            Vector2Int spawnPos = FindValidSpawnPosition(innerTiles, usedPositions);
            if (spawnPos != Vector2Int.zero)
            {
                SpawnPositions.Add(spawnPos);
                usedPositions.Add(spawnPos);
            }
        }
    }

    private Vector2Int FindValidSpawnPosition(List<Vector2Int> availableTiles, HashSet<Vector2Int> usedPositions)
    {
        int attempts = 0;
        Vector2Int spawnPos;
        
        do {
            spawnPos = availableTiles[Random.Range(0, availableTiles.Count)];
            attempts++;
        } while (usedPositions.Contains(spawnPos) && attempts < 10);
        
        return attempts < 10 ? spawnPos : Vector2Int.zero;
    }

    /// <summary>
    /// Gets a random spawn position from the generated list.
    /// </summary>
    public Vector2Int GetRandomSpawnPosition()
    {
        if (SpawnPositions.Count == 0) return Center;
        return SpawnPositions[Random.Range(0, SpawnPositions.Count)];
    }

    /// <summary>
    /// Marks the room as cleared and updates its state.
    /// </summary>
    public void MarkAsCleared()
    {
        IsCleared = true;
        if (State == RoomAccess.Closed)
        {
            State = RoomAccess.Open;
        }
    }

    /// <summary>
    /// Marks the room as revealed to the player.
    /// </summary>
    public void Reveal()
    {
        IsRevealed = true;
    }

    private RoomAccess GetDefaultStateForType(RoomType type)
    {
        return type switch 
        { 
            RoomType.Combat or RoomType.Boss => RoomAccess.Closed, 
            _ => RoomAccess.Open 
        };
    }
}

/// <summary>
/// Accessibility state of a room.
/// </summary>
public enum RoomAccess
{
    Open,
    Closed,
    Locked
}

/// <summary>
/// Purpose and functionality of a room.
/// </summary>
public enum RoomType
{
    // Critical path
    Entrance,
    Exit,

    // Standard rooms
    Empty,
    Combat,
    Shop,
    Treasure,

    // Special rooms
    Boss,
    Survival,
    Puzzle,
    Secret
}

/// <summary>
/// Serialized data for saving room state.
/// </summary>
[System.Serializable]
public class RoomSaveData
{
    public int RoomID;
    public RoomAccess Access;
    public bool IsRevealed;
    public bool IsCleared;
}

// WallModel.cs
using UnityEngine;

/// <summary>
/// Represents wall segments that need gameplay interaction.
/// Created sparingly for destructible or interactive walls only.
/// </summary>
public class WallModel
{
    /// <summary>Grid position of the wall.</summary>
    public Vector2Int Position { get; private set; }
    
    /// <summary>Type of wall for rendering and behavior.</summary>
    public WallType Type { get; private set; }
    
    /// <summary>Whether this wall can be destroyed.</summary>
    public bool IsDestructible { get; private set; }
    
    /// <summary>Current health of the wall (if destructible).</summary>
    public int Health { get; private set; }
    
    /// <summary>Maximum health of the wall (if destructible).</summary>
    public int MaxHealth { get; private set; }
    
    /// <summary>World position for gameplay.</summary>
    public Vector3 WorldPosition => new Vector3(Position.x + 0.5f, 0.5f, Position.y + 0.5f);
    
    /// <summary>Whether the wall has been destroyed.</summary>
    public bool IsDestroyed => IsDestructible && Health <= 0;

    public WallModel(Vector2Int position, WallType type, bool isDestructible = false)
    {
        Position = position;
        Type = type;
        IsDestructible = isDestructible;
        
        if (isDestructible)
        {
            MaxHealth = CalculateMaxHealth(type);
            Health = MaxHealth;
        }
    }

    /// <summary>
    /// Applies damage to the wall if it's destructible.
    /// </summary>
    public void Damage(int damage)
    {
        if (!IsDestructible || IsDestroyed) return;
        
        Health = Mathf.Max(0, Health - damage);
    }

    /// <summary>
    /// Repairs the wall by the specified amount.
    /// </summary>
    public void Repair(int amount)
    {
        if (!IsDestructible) return;
        
        Health = Mathf.Min(MaxHealth, Health + amount);
    }

    /// <summary>
    /// Completely repairs the wall.
    /// </summary>
    public void FullRepair()
    {
        if (!IsDestructible) return;
        
        Health = MaxHealth;
    }

    /// <summary>
    /// Makes the wall indestructible.
    /// </summary>
    public void MakeIndestructible()
    {
        IsDestructible = false;
        Health = 0;
        MaxHealth = 0;
    }

    /// <summary>
    /// Gets the health percentage (0-1) for UI displays.
    /// </summary>
    public float GetHealthPercentage()
    {
        if (!IsDestructible) return 1f;
        return (float)Health / MaxHealth;
    }

    private int CalculateMaxHealth(WallType wallType)
    {
        return wallType switch
        {
            WallType.North or WallType.South or WallType.East or WallType.West => 100,
            WallType.Corridor => 50,
            WallType.Interior => 75,
            _ => 100
        };
    }
}

/// <summary>
/// Types of walls with different positions and properties.
/// </summary>
public enum WallType
{
    // Cardinal directions
    North,
    South,
    East,
    West,
    
    // Corners
    NorthEastCorner,
    NorthWestCorner,
    SouthEastCorner,
    SouthWestCorner,
    
    // Special types
    Interior,
    Doorway,
    Corridor,
    Secret
}