// AdvancedMeshCombiner.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Advanced mesh combining system that handles large numbers of meshes efficiently.
/// Supports material-based grouping and automatic vertex limit management.
/// </summary>
[System.Serializable]
public class AdvancedMeshCombiner
{
    [System.Serializable]
    public class CombinedMeshData
    {
        public string Name;
        public List<CombineInstance> CombineInstances = new List<CombineInstance>();
        public Material Material;
        public int VertexCount => CalculateVertexCount();
        
        private int CalculateVertexCount()
        {
            int total = 0;
            foreach (var instance in CombineInstances)
            {
                if (instance.mesh != null)
                    total += instance.mesh.vertexCount;
            }
            return total;
        }
    }

    private Dictionary<Material, CombinedMeshData> _materialMeshes = new Dictionary<Material, CombinedMeshData>();
    private const int MAX_VERTICES_PER_MESH = 60000;

    public void AddMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale, Material material)
    {
        if (mesh == null || material == null) return;

        if (!_materialMeshes.ContainsKey(material))
        {
            _materialMeshes[material] = new CombinedMeshData
            {
                Name = $"Combined_{material.name}",
                Material = material
            };
        }

        var combineInstance = new CombineInstance
        {
            mesh = mesh,
            transform = Matrix4x4.TRS(position, rotation, scale)
        };

        _materialMeshes[material].CombineInstances.Add(combineInstance);
    }

    public List<GameObject> BuildAllCombinedMeshes(Transform parent)
    {
        List<GameObject> combinedObjects = new List<GameObject>();
        
        foreach (var kvp in _materialMeshes)
        {
            var meshData = kvp.Value;
            
            if (meshData.CombineInstances.Count == 0) continue;

            // Split if too large
            if (meshData.VertexCount > MAX_VERTICES_PER_MESH)
            {
                var splitMeshes = BuildSplitMeshes(meshData, parent);
                combinedObjects.AddRange(splitMeshes);
            }
            else
            {
                var combinedObject = BuildSingleCombinedMesh(meshData, parent);
                if (combinedObject != null) combinedObjects.Add(combinedObject);
            }
        }

        _materialMeshes.Clear();
        return combinedObjects;
    }

    private GameObject BuildSingleCombinedMesh(CombinedMeshData meshData, Transform parent)
    {
        try
        {
            GameObject combinedObject = new GameObject(meshData.Name);
            combinedObject.transform.SetParent(parent);

            MeshFilter meshFilter = combinedObject.AddComponent<MeshFilter>();
            MeshRenderer meshRenderer = combinedObject.AddComponent<MeshRenderer>();

            Mesh combinedMesh = new Mesh();
            combinedMesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
            combinedMesh.CombineMeshes(meshData.CombineInstances.ToArray());
            
            meshFilter.mesh = combinedMesh;
            meshRenderer.sharedMaterial = meshData.Material;

            // Add optimized collider
            var meshCollider = combinedObject.AddComponent<MeshCollider>();
            meshCollider.sharedMesh = combinedMesh;

            Debug.Log($"Created combined mesh: {meshData.Name} with {meshData.CombineInstances.Count} instances, {combinedMesh.vertexCount} vertices");
            return combinedObject;
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Failed to create combined mesh {meshData.Name}: {e.Message}");
            return null;
        }
    }

    private List<GameObject> BuildSplitMeshes(CombinedMeshData meshData, Transform parent, int maxInstancesPerChunk = 2000)
    {
        List<GameObject> chunks = new List<GameObject>();
        int instanceCount = meshData.CombineInstances.Count;
        int chunkCount = Mathf.CeilToInt((float)instanceCount / maxInstancesPerChunk);

        for (int i = 0; i < chunkCount; i++)
        {
            int startIndex = i * maxInstancesPerChunk;
            int count = Mathf.Min(maxInstancesPerChunk, instanceCount - startIndex);
            
            var chunkData = new CombinedMeshData
            {
                Name = $"{meshData.Name}_Chunk{i+1}",
                Material = meshData.Material
            };
            
            chunkData.CombineInstances.AddRange(meshData.CombineInstances.GetRange(startIndex, count));
            
            var chunkObject = BuildSingleCombinedMesh(chunkData, parent);
            if (chunkObject != null) chunks.Add(chunkObject);
        }

        Debug.Log($"Split {meshData.Name} into {chunks.Count} chunks");
        return chunks;
    }
}

// GizmoDoorRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Renders doors in Gizmo mode using colored cubes for debugging and visualization.
/// </summary>
public class GizmoDoorRenderer : IDoorRenderer
{
    private MaterialManager _materialManager;

    public GizmoDoorRenderer(MaterialManager materialManager)
    {
        _materialManager = materialManager;
    }

    /// <summary>
    /// Renders all doors in the layout as individual cubes.
    /// </summary>
    public void RenderDoors(LevelModel layout, Transform parent, bool enableCollision)
    {
        if (layout?.AllDoorTiles == null) return;
        
        foreach (var doorPos in layout.AllDoorTiles)
        {
            var door = CreateDoorAtPosition(doorPos);
            if (door != null)
            {
                door.transform.SetParent(parent);
                
                if (enableCollision && door != null) 
                {
                    AddCollisionToObject(door, "Door");
                }
            }
        }
    }

    private GameObject CreateDoorAtPosition(Vector2Int gridPos)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 0.4f, gridPos.y + 0.5f);
        var door = GameObject.CreatePrimitive(PrimitiveType.Cube);
        door.transform.position = worldPos;
        door.transform.localScale = new Vector3(1f, 0.8f, 1f);
        door.name = $"Door_{gridPos.x}_{gridPos.y}";
        
        // Add DoorController and configure
        var doorController = door.AddComponent<DoorController>();
        doorController.doorModel = door; // The cube itself is the model
        
        ApplyDoorMaterial(door);
        return door;
    }

    private void ApplyDoorMaterial(GameObject obj)
    {
        if (obj == null) return;
        
        var renderer = obj.GetComponent<Renderer>();
        if (renderer != null)
        {
            renderer.sharedMaterial = _materialManager.GetDoorMaterial();
        }
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;

        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();

        if (objectType == "Door")
        {
            var rb = obj.GetComponent<Rigidbody>();
            if (rb == null)
            {
                rb = obj.AddComponent<Rigidbody>();
                rb.isKinematic = true;
            }
        }
    }
}

// GizmoFloorRenderer.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Renders floors in Gizmo mode using colored cubes for debugging and visualization.
/// </summary>
public class GizmoFloorRenderer : IFloorRenderer
{
    private MaterialManager _materialManager;
    private MeshCombiner _meshCombiner;

    public GizmoFloorRenderer(MaterialManager materialManager)
    {
        _materialManager = materialManager;
        _meshCombiner = new MeshCombiner();
    }

    /// <summary>
    /// Renders floors as combined meshes grouped by room type for optimal performance.
    /// </summary>
    public List<GameObject> RenderCombinedFloorsByRoomType(LevelModel layout, List<RoomModel> rooms, Transform parent)
    {
        if (layout?.AllFloorTiles == null || rooms == null)
        {
            Debug.LogError("Cannot render combined floors: layout or rooms is null");
            return new List<GameObject>();
        }

        var floorGroups = GroupFloorTilesByRoomType(layout, rooms);
        var meshContainers = new List<GameObject>();

        Debug.Log($"Combining floors by room type: {floorGroups.Count} room types found");
        
        foreach (var floorGroup in floorGroups)
        {
            if (floorGroup.Value.Count > 0)
            {
                Debug.Log($"Creating combined mesh for {floorGroup.Key}: {floorGroup.Value.Count} tiles");
                var combinedMesh = _meshCombiner.CreateCombinedMesh(floorGroup.Value, $"Floors_{floorGroup.Key}", parent);
                if (combinedMesh != null)
                {
                    ApplyRoomMaterial(combinedMesh, floorGroup.Key);
                    meshContainers.Add(combinedMesh);
                    Debug.Log($"Successfully created combined mesh for {floorGroup.Key}");
                }
                else
                {
                    Debug.LogError($"Failed to create combined mesh for {floorGroup.Key}");
                }
            }
            else
            {
                Debug.LogWarning($"No floor tiles found for room type: {floorGroup.Key}");
            }
        }

        Debug.Log($"Created {meshContainers.Count} combined floor meshes");
        return meshContainers;
    }

    /// <summary>
    /// Renders floors as individual cubes for detailed debugging.
    /// </summary>
    public void RenderIndividualFloors(LevelModel layout, List<RoomModel> rooms, Transform parent, bool enableCollision)
    {
        if (layout?.AllFloorTiles == null || rooms == null)
        {
            Debug.LogError("Cannot render individual floors: layout or rooms is null");
            return;
        }

        foreach (var floorPos in layout.AllFloorTiles)
        {
            var floor = CreateFloorAtPosition(floorPos);
            if (floor != null)
            {
                floor.transform.SetParent(parent);
                
                var roomType = GetRoomTypeAtPosition(floorPos, rooms, layout);
                ApplyRoomMaterial(floor, roomType);
                
                if (enableCollision)
                    AddCollisionToObject(floor, "Floor");
            }
        }
    }

    private Dictionary<RoomType, List<Vector3>> GroupFloorTilesByRoomType(LevelModel layout, List<RoomModel> rooms)
    {
        var floorGroups = new Dictionary<RoomType, List<Vector3>>();
        
        foreach (var floorPos in layout.AllFloorTiles)
        {
            var roomType = GetRoomTypeAtPosition(floorPos, rooms, layout);
            
            if (!floorGroups.ContainsKey(roomType))
                floorGroups[roomType] = new List<Vector3>();
                
            floorGroups[roomType].Add(new Vector3(floorPos.x + 0.5f, 0, floorPos.y + 0.5f));
        }

        return floorGroups;
    }

    private RoomType GetRoomTypeAtPosition(Vector2Int position, List<RoomModel> rooms, LevelModel layout)
    {
        if (layout == null || rooms == null) return RoomType.Combat;
        
        var room = layout.GetRoomAtPosition(position);
        return room?.Type ?? RoomType.Combat;
    }

    private GameObject CreateFloorAtPosition(Vector2Int gridPos)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 0, gridPos.y + 0.5f);
        var floor = GameObject.CreatePrimitive(PrimitiveType.Cube);
        floor.transform.position = worldPos;
        floor.transform.localScale = new Vector3(1f, 0.1f, 1f);
        floor.name = $"Floor_{gridPos.x}_{gridPos.y}";
        return floor;
    }

    private void ApplyRoomMaterial(GameObject obj, RoomType roomType)
    {
        if (obj == null) return;
        
        var renderer = obj.GetComponent<Renderer>();
        if (renderer != null)
        {
            renderer.sharedMaterial = _materialManager.GetRoomMaterial(roomType);
        }
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;
        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();
    }
}

// GizmoWallRenderer.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Renders walls in Gizmo mode using colored cubes for debugging and visualization.
/// </summary>
public class GizmoWallRenderer : IWallRenderer
{
    private MaterialManager _materialManager;
    private MeshCombiner _meshCombiner;

    public GizmoWallRenderer(MaterialManager materialManager)
    {
        _materialManager = materialManager;
        _meshCombiner = new MeshCombiner();
    }

    /// <summary>
    /// Renders walls as combined meshes grouped by wall type for optimal performance.
    /// </summary>
    public List<GameObject> RenderCombinedWallsByType(LevelModel layout, Transform parent)
    {
        if (layout?.AllWallTiles == null || layout.WallTypes == null)
        {
            Debug.LogError("Cannot render combined walls: layout data is null");
            return new List<GameObject>();
        }

        var wallGroups = GroupWallTilesByType(layout);
        var meshContainers = new List<GameObject>();

        foreach (var wallGroup in wallGroups)
        {
            if (wallGroup.Value.Count > 0)
            {
                var combinedMesh = _meshCombiner.CreateCombinedMesh(wallGroup.Value, $"Walls_{wallGroup.Key}", parent);
                if (combinedMesh != null)
                {
                    ApplyWallMaterial(combinedMesh, wallGroup.Key);
                    meshContainers.Add(combinedMesh);
                }
            }
        }

        return meshContainers;
    }

    /// <summary>
    /// Renders walls as individual cubes for detailed debugging.
    /// </summary>
    public void RenderIndividualWalls(LevelModel layout, Transform parent, bool enableCollision)
    {
        if (layout?.AllWallTiles == null || layout.WallTypes == null) return;

        foreach (var wallPos in layout.AllWallTiles)
        {
            if (layout.WallTypes.TryGetValue(wallPos, out var wallType))
            {
                var wall = CreateWallAtPosition(wallPos, wallType);
                if (wall != null)
                {
                    wall.transform.SetParent(parent);
                    
                    if (enableCollision)
                        AddCollisionToObject(wall, "Wall");
                }
            }
        }
    }

    private Dictionary<WallType, List<Vector3>> GroupWallTilesByType(LevelModel layout)
    {
        var wallGroups = new Dictionary<WallType, List<Vector3>>();
        
        foreach (var wallPos in layout.AllWallTiles)
        {
            if (layout.WallTypes.TryGetValue(wallPos, out var wallType))
            {
                if (!wallGroups.ContainsKey(wallType))
                    wallGroups[wallType] = new List<Vector3>();
                    
                wallGroups[wallType].Add(new Vector3(wallPos.x + 0.5f, 0.5f, wallPos.y + 0.5f));
            }
        }

        return wallGroups;
    }

    private GameObject CreateWallAtPosition(Vector2Int gridPos, WallType wallType)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 0.5f, gridPos.y + 0.5f);
        var wall = GameObject.CreatePrimitive(PrimitiveType.Cube);
        wall.transform.position = worldPos;
        wall.transform.localScale = new Vector3(1f, 1f, 1f);
        wall.name = $"Wall_{wallType}_{gridPos.x}_{gridPos.y}";
        ApplyWallMaterial(wall, wallType);
        return wall;
    }

    private void ApplyWallMaterial(GameObject obj, WallType wallType)
    {
        if (obj == null) return;
        
        var renderer = obj.GetComponent<Renderer>();
        if (renderer != null)
        {
            renderer.sharedMaterial = _materialManager.GetWallMaterial(wallType);
        }
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;
        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();
    }
}

// MeshCombiner.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Utility class for combining multiple meshes into single mesh objects for performance optimization.
/// Handles vertex limits and chunking automatically.
/// </summary>
public class MeshCombiner
{
    /// <summary>
    /// Creates a combined mesh from a list of positions, handling vertex limits automatically.
    /// </summary>
    public GameObject CreateCombinedMesh(List<Vector3> positions, string name, Transform parent)
    {
        if (positions == null || positions.Count == 0) 
        {
            Debug.LogWarning($"No positions provided for mesh: {name}");
            return null;
        }

        // Check if we need to split due to vertex limit
        const int maxVerticesPerMesh = 60000; // Conservative limit
        const int verticesPerCube = 24; // A cube has 24 vertices in Unity

        int maxCubesPerMesh = maxVerticesPerMesh / verticesPerCube;
        
        if (positions.Count > maxCubesPerMesh)
        {
            Debug.Log($"Splitting {name}: {positions.Count} cubes exceeds vertex limit, splitting into chunks");
            return CreateSplitMeshes(positions, name, parent, maxCubesPerMesh);
        }

        return CreateSingleCombinedMesh(positions, name, parent);
    }

    private GameObject CreateSingleCombinedMesh(List<Vector3> positions, string name, Transform parent)
    {
        // Create container object
        GameObject container = new GameObject(name);
        container.transform.SetParent(parent);
        
        // Create individual cubes as children (will be combined)
        var meshFilters = new List<MeshFilter>();
        
        foreach (var position in positions)
        {
            var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
            cube.transform.position = position;
            cube.transform.SetParent(container.transform);
            
            var meshFilter = cube.GetComponent<MeshFilter>();
            if (meshFilter != null && meshFilter.sharedMesh != null)
                meshFilters.Add(meshFilter);
        }

        Debug.Log($"Created {meshFilters.Count} cubes for {name}");

        // Combine meshes if we have multiple
        if (meshFilters.Count > 1)
        {
            CombineMeshesInContainer(container);
        }
        else if (meshFilters.Count == 1)
        {
            // Handle single mesh case
            SetupSingleMeshContainer(container, meshFilters[0]);
        }
        else
        {
            Debug.LogWarning($"No valid meshes created for {name}");
            Object.DestroyImmediate(container);
            return null;
        }
        
        return container;
    }

    private void SetupSingleMeshContainer(GameObject container, MeshFilter meshFilter)
    {
        var containerFilter = container.GetComponent<MeshFilter>();
        if (containerFilter == null)
            containerFilter = container.AddComponent<MeshFilter>();
            
        MeshRenderer containerRenderer = container.GetComponent<MeshRenderer>();
        if (containerRenderer == null)
            containerRenderer = container.AddComponent<MeshRenderer>();
        
        containerFilter.mesh = meshFilter.sharedMesh;
        
        // Copy material from the cube
        var cubeRenderer = meshFilter.GetComponent<Renderer>();
        if (cubeRenderer != null)
        {
            containerRenderer.sharedMaterial = cubeRenderer.sharedMaterial;
        }
        
        // Destroy the child cube
        Object.DestroyImmediate(meshFilter.gameObject);
    }

    private GameObject CreateSplitMeshes(List<Vector3> positions, string name, Transform parent, int maxCubesPerChunk)
    {
        GameObject mainContainer = new GameObject(name);
        mainContainer.transform.SetParent(parent);
        
        int chunkCount = Mathf.CeilToInt((float)positions.Count / maxCubesPerChunk);
        int chunksCreated = 0;
        
        for (int i = 0; i < positions.Count; i += maxCubesPerChunk)
        {
            int chunkSize = Mathf.Min(maxCubesPerChunk, positions.Count - i);
            var chunkPositions = positions.GetRange(i, chunkSize);
            
            var chunk = CreateSingleCombinedMesh(chunkPositions, $"{name}_Chunk{chunksCreated}", mainContainer.transform);
            if (chunk != null)
            {
                chunksCreated++;
            }
        }
        
        Debug.Log($"Created {chunksCreated} chunks for {name}");
        return mainContainer;
    }

    private void CombineMeshesInContainer(GameObject container)
    {
        MeshFilter[] meshFilters = container.GetComponentsInChildren<MeshFilter>();
        
        if (meshFilters.Length == 0) return;

        List<CombineInstance> combineInstances = new List<CombineInstance>();
        
        // Skip the first mesh filter (it's the container's own filter)
        for (int i = 0; i < meshFilters.Length; i++)
        {
            if (meshFilters[i].sharedMesh != null)
            {
                CombineInstance combineInstance = new CombineInstance();
                combineInstance.mesh = meshFilters[i].sharedMesh;
                combineInstance.transform = meshFilters[i].transform.localToWorldMatrix;
                combineInstances.Add(combineInstance);
            }
        }

        if (combineInstances.Count == 0) return;

        // Check if we'll exceed vertex limit and use chunking if needed
        int totalVertices = CalculateTotalVertices(combineInstances);
        
        if (totalVertices > 60000) // Safe margin below 65k
        {
            Debug.LogWarning($"Mesh too large ({totalVertices} vertices), using chunking...");
            CombineMeshesInChunks(container, combineInstances);
        }
        else
        {
            CombineAllMeshes(container, combineInstances);
        }
    }

    private void CombineAllMeshes(GameObject container, List<CombineInstance> combineInstances)
    {
        // Create combined mesh
        Mesh combinedMesh = new Mesh();
        
        // Set index format to support more vertices
        combinedMesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
        
        combinedMesh.CombineMeshes(combineInstances.ToArray());
        
        // Set up the container with combined mesh
        SetupContainerWithMesh(container, combinedMesh);
        
        // Destroy individual child objects
        DestroyChildObjects(container);
    }

    private void SetupContainerWithMesh(GameObject container, Mesh combinedMesh)
    {
        MeshFilter containerFilter = container.GetComponent<MeshFilter>();
        if (containerFilter == null)
            containerFilter = container.AddComponent<MeshFilter>();
            
        MeshRenderer containerRenderer = container.GetComponent<MeshRenderer>();
        if (containerRenderer == null)
            containerRenderer = container.AddComponent<MeshRenderer>();
        
        containerFilter.mesh = combinedMesh;
        
        // Copy material from first child
        if (container.transform.childCount > 0)
        {
            var firstRenderer = container.transform.GetChild(0).GetComponent<Renderer>();
            if (firstRenderer != null)
            {
                containerRenderer.sharedMaterial = firstRenderer.sharedMaterial;
            }
        }
    }

    private void CombineMeshesInChunks(GameObject container, List<CombineInstance> combineInstances)
    {
        const int maxVerticesPerChunk = 60000; // Safe margin
        List<CombineInstance> currentChunk = new List<CombineInstance>();
        int currentVertexCount = 0;
        int chunkIndex = 0;

        // Clear existing components from container
        ClearContainerComponents(container);

        for (int i = 0; i < combineInstances.Count; i++)
        {
            var combineInstance = combineInstances[i];
            int meshVertices = combineInstance.mesh.vertexCount;

            // If adding this mesh would exceed limit and we have items in current chunk, create chunk
            if (currentVertexCount + meshVertices > maxVerticesPerChunk && currentChunk.Count > 0)
            {
                CreateChunkMesh(container, currentChunk, chunkIndex);
                currentChunk.Clear();
                currentVertexCount = 0;
                chunkIndex++;
            }

            currentChunk.Add(combineInstance);
            currentVertexCount += meshVertices;
        }

        // Create final chunk
        if (currentChunk.Count > 0)
        {
            CreateChunkMesh(container, currentChunk, chunkIndex);
        }

        // Destroy individual child objects
        DestroyChildObjects(container);

        Debug.Log($"Created {chunkIndex + 1} mesh chunks to avoid vertex limit");
    }

    private void ClearContainerComponents(GameObject container)
    {
        var existingFilter = container.GetComponent<MeshFilter>();
        var existingRenderer = container.GetComponent<MeshRenderer>();
        if (existingFilter != null) Object.DestroyImmediate(existingFilter);
        if (existingRenderer != null) Object.DestroyImmediate(existingRenderer);
    }

    private void CreateChunkMesh(GameObject container, List<CombineInstance> combineInstances, int chunkIndex)
    {
        if (combineInstances.Count == 0) return;

        // Create chunk object
        GameObject chunk = new GameObject($"Chunk_{chunkIndex}");
        chunk.transform.SetParent(container.transform);
        chunk.transform.localPosition = Vector3.zero;

        // Create combined mesh for this chunk
        Mesh combinedMesh = new Mesh();
        combinedMesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
        combinedMesh.CombineMeshes(combineInstances.ToArray());

        // Add components to chunk
        MeshFilter chunkFilter = chunk.AddComponent<MeshFilter>();
        MeshRenderer chunkRenderer = chunk.AddComponent<MeshRenderer>();
        
        chunkFilter.mesh = combinedMesh;

        // Copy material from first combine instance if possible
        CopyMaterialToChunk(container, chunkRenderer);
    }

    private void CopyMaterialToChunk(GameObject container, MeshRenderer chunkRenderer)
    {
        // Try to find a renderer in the original children to copy material from
        foreach (Transform child in container.transform)
        {
            var renderer = child.GetComponent<Renderer>();
            if (renderer != null)
            {
                chunkRenderer.sharedMaterial = renderer.sharedMaterial;
                break;
            }
        }
    }

    private void DestroyChildObjects(GameObject container)
    {
        for (int i = container.transform.childCount - 1; i >= 0; i--)
        {
            Object.DestroyImmediate(container.transform.GetChild(i).gameObject);
        }
    }

    private int CalculateTotalVertices(List<CombineInstance> combineInstances)
    {
        int total = 0;
        foreach (var instance in combineInstances)
        {
            if (instance.mesh != null)
            {
                total += instance.mesh.vertexCount;
            }
        }
        return total;
    }
}

// OptimizedPrefabRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// High-performance prefab renderer that uses mesh combining for optimal rendering.
/// Supports biome themes and efficient geometry batching.
/// </summary>
public class OptimizedPrefabRenderer
{
    private BiomeManager _biomeManager;
    private BiomeTheme _currentTheme;
    private int _currentFloor;
    private AdvancedMeshCombiner _meshCombiner;

    public OptimizedPrefabRenderer(BiomeManager biomeManager)
    {
        _biomeManager = biomeManager;
        _meshCombiner = new AdvancedMeshCombiner();
    }

    public void SetThemeForFloor(int floorLevel, int seed)
    {
        _currentFloor = floorLevel;
        _currentTheme = _biomeManager.GetThemeForFloor(floorLevel, seed);
        Debug.Log($"Using theme: {_currentTheme?.Name} for floor {floorLevel}");
    }

    /// <summary>
    /// Renders all floor tiles using combined meshes for optimal performance.
    /// </summary>
    public void RenderFloorsOptimized(LevelModel layout, Transform parent)
    {
        if (_currentTheme == null)
        {
            Debug.LogError("Current theme is null in RenderFloorsOptimized!");
            return;
        }

        if (layout?.AllFloorTiles == null)
        {
            Debug.LogError("Layout or AllFloorTiles is null in RenderFloorsOptimized!");
            return;
        }

        Debug.Log($"=== FLOOR RENDERING DEBUG ===");
        Debug.Log($"Theme: {_currentTheme.Name}");
        Debug.Log($"Floor prefab path: {_currentTheme.FloorPrefabPath}");
        Debug.Log($"Floor tiles count: {layout.AllFloorTiles.Count}");

        var floorPrefab = _biomeManager.GetFloorPrefab(_currentTheme);

        if (floorPrefab == null)
        {
            Debug.LogError($"Floor prefab is NULL for theme: {_currentTheme.Name}");
            Debug.LogError($"Tried to load from: {_currentTheme.FloorPrefabPath}");
            
            // Test if Resources loading works at all
            var testPrefab = Resources.Load<GameObject>("Themes/Default/FloorPrefab");
            Debug.Log($"Direct Resources load result: {testPrefab != null}");
            
            RenderFloorsAsPrimitives(layout, parent);
            return;
        }

        Debug.Log($"✓ Successfully loaded floor prefab: {floorPrefab.name}");

        Mesh floorMesh = GetPrefabMesh(floorPrefab);
        Material floorMaterial = GetPrefabMaterial(floorPrefab);
        Vector3 floorScale = floorPrefab.transform.localScale;

        Debug.Log($"Floor mesh: {floorMesh != null}");
        Debug.Log($"Floor material: {floorMaterial != null}");
        Debug.Log($"Floor scale: {floorScale}");

        if (floorMesh == null)
        {
            Debug.LogError("Could not get mesh from floor prefab!");
            // Check what's actually on the prefab
            var meshFilter = floorPrefab.GetComponentInChildren<MeshFilter>();
            Debug.Log($"MeshFilter on prefab: {meshFilter != null}");
            if (meshFilter != null) Debug.Log($"MeshFilter mesh: {meshFilter.sharedMesh != null}");
            return;
        }

        if (floorMaterial == null)
        {
            Debug.LogError("Could not get material from floor prefab!");
            return;
        }

        int floorsRendered = 0;
        foreach (var floorPos in layout.AllFloorTiles)
        {
            Vector3 worldPos = new Vector3(floorPos.x + 0.5f, 0.5f, floorPos.y + 0.5f);
            _meshCombiner.AddMesh(floorMesh, worldPos, Quaternion.identity, floorScale, floorMaterial);
            floorsRendered++;
        }

        Debug.Log($"✓ Processed {floorsRendered} floor positions for combining");
        Debug.Log($"=== END FLOOR DEBUG ===");
    }

    /// <summary>
    /// Renders all wall tiles using combined meshes for optimal performance.
    /// </summary>
    public void RenderWallsOptimized(LevelModel layout, Transform parent)
    {
        if (_currentTheme == null || layout?.AllWallTiles == null) return;

        var wallPrefab = _biomeManager.GetWallPrefab(_currentTheme);

        if (wallPrefab == null)
        {
            Debug.LogWarning("Wall prefab not found, using fallback logic");
            RenderWallsAsPrimitives(layout, parent);
            return;
        }

        Mesh wallMesh = GetPrefabMesh(wallPrefab);
        Material wallMaterial = GetPrefabMaterial(wallPrefab);
        Vector3 wallScale = wallPrefab.transform.localScale;

        if (wallMesh == null || wallMaterial == null) return;

        foreach (var wallPos in layout.AllWallTiles)
        {
            if (layout.WallTypes.TryGetValue(wallPos, out var wallType))
            {
                Vector3 worldPos = new Vector3(wallPos.x + 0.5f, 4.5f, wallPos.y + 0.5f);
                Quaternion rotation = GetWallRotation(wallType);
                _meshCombiner.AddMesh(wallMesh, worldPos, rotation, wallScale, wallMaterial);
            }
        }
    }

    /// <summary>
    /// Renders all door tiles and door tops using combined meshes.
    /// </summary>
    public void RenderDoorsOptimized(LevelModel layout, Transform parent)
    {
        if (_currentTheme == null || layout?.AllDoorTiles == null) return;

        // Doors
        var doorPrefab = _biomeManager.GetDoorPrefab(_currentTheme);
        if (doorPrefab != null)
        {
            Mesh doorMesh = GetPrefabMesh(doorPrefab);
            Material doorMaterial = GetPrefabMaterial(doorPrefab);
            Vector3 doorScale = doorPrefab.transform.localScale;

            if (doorMesh != null && doorMaterial != null)
            {
                foreach (var doorPos in layout.AllDoorTiles)
                {
                    Vector3 worldPos = new Vector3(doorPos.x + 0.5f, 2f, doorPos.y + 0.5f);
                    Quaternion rotation = GetDoorRotation(layout, doorPos);
                    _meshCombiner.AddMesh(doorMesh, worldPos, rotation, doorScale, doorMaterial);
                }
            }
        }

        // Door tops
        var doorTopPrefab = _biomeManager.GetDoorTopPrefab(_currentTheme);
        if (doorTopPrefab != null)
        {
            Mesh doorTopMesh = GetPrefabMesh(doorTopPrefab);
            Material doorTopMaterial = GetPrefabMaterial(doorTopPrefab);
            Vector3 doorTopScale = doorTopPrefab.transform.localScale;

            if (doorTopMesh != null && doorTopMaterial != null)
            {
                foreach (var doorPos in layout.AllDoorTiles)
                {
                    Vector3 worldPos = new Vector3(doorPos.x + 0.5f, 6f, doorPos.y + 0.5f);
                    _meshCombiner.AddMesh(doorTopMesh, worldPos, Quaternion.identity, doorTopScale, doorTopMaterial);
                }
            }
        }
    }

    /// <summary>
    /// Finalizes all combined meshes and builds them in the scene.
    /// </summary>
    public void FinalizeRendering(Transform parent)
    {
        // Build all combined meshes at once
        var combinedObjects = _meshCombiner.BuildAllCombinedMeshes(parent);
        Debug.Log($"Finalized rendering with {combinedObjects.Count} combined mesh objects");
    }

    /// <summary>
    /// Renders a ceiling plane above the entire dungeon.
    /// </summary>
    public void RenderCeilingOptimized(LevelModel layout, Transform parent)
    {
        if (layout?.OverallBounds == null) return;

        // Create one main ceiling plane at Y=9
        GameObject ceiling = GameObject.CreatePrimitive(PrimitiveType.Plane);
        ceiling.name = "MainCeiling";
        ceiling.transform.SetParent(parent);
        
        // Position at top of walls
        BoundsInt dungeonBounds = layout.OverallBounds;
        Vector3 center = new Vector3(dungeonBounds.center.x, 9f, dungeonBounds.center.y);
        ceiling.transform.position = center;
        
        // Scale to cover entire dungeon
        float scaleX = Mathf.Ceil(dungeonBounds.size.x * 0.1f); 
        float scaleZ = Mathf.Ceil(dungeonBounds.size.y * 0.1f);
        ceiling.transform.localScale = new Vector3(scaleX, 1f, scaleZ);
        
        // Apply one-sided mirror material
        Renderer renderer = ceiling.GetComponent<Renderer>();
        renderer.sharedMaterial = CreateOneSidedMirrorMaterial();
        
        // Remove collider - ceiling shouldn't block movement
        GameObject.DestroyImmediate(ceiling.GetComponent<Collider>());
    }

    /// <summary>
    /// Renders a void plane below the dungeon to catch falling objects.
    /// </summary>
    public void RenderVoidPlane(LevelModel layout, Transform parent)
    {
        if (layout?.OverallBounds == null) return;

        GameObject voidPlane = GameObject.CreatePrimitive(PrimitiveType.Plane);
        voidPlane.name = "VoidPlane";
        voidPlane.transform.SetParent(parent);
        
        // Position well below everything
        BoundsInt dungeonBounds = layout.OverallBounds;
        Vector3 center = new Vector3(dungeonBounds.center.x, -5f, dungeonBounds.center.y);
        voidPlane.transform.position = center;
        
        // Scale to cover entire dungeon + large buffer
        float scaleX = Mathf.Ceil(dungeonBounds.size.x * 0.2f); 
        float scaleZ = Mathf.Ceil(dungeonBounds.size.y * 0.2f);
        voidPlane.transform.localScale = new Vector3(scaleX, 1f, scaleZ);
        
        // Pure black material
        Renderer renderer = voidPlane.GetComponent<Renderer>();
        Material voidMaterial = new Material(Shader.Find("Standard"));
        voidMaterial.color = Color.black;
        voidMaterial.SetFloat("_Metallic", 0f);
        voidMaterial.SetFloat("_Glossiness", 0f);
        renderer.sharedMaterial = voidMaterial;
    }

    #region Helper Methods

    private Mesh GetPrefabMesh(GameObject prefab)
    {
        if (prefab == null) return null;
        var meshFilter = prefab.GetComponentInChildren<MeshFilter>();
        return meshFilter != null ? meshFilter.sharedMesh : null;
    }

    private Material GetPrefabMaterial(GameObject prefab)
    {
        if (prefab == null) return null;
        var renderer = prefab.GetComponentInChildren<Renderer>();
        return renderer != null ? renderer.sharedMaterial : null;
    }

    private Quaternion GetDoorRotation(LevelModel layout, Vector2Int doorPos)
    {
        // First, determine which wall the door is actually on
        var adjacentRoom = FindAdjacentRoom(layout, doorPos);
        if (adjacentRoom != null)
        {
            return GetDoorRotationFromRoom(adjacentRoom, doorPos);
        }

        // Fallback: analyze adjacent tiles to guess orientation
        Vector2Int[] directions = new Vector2Int[]
        {
            new Vector2Int(0, 1),  // North
            new Vector2Int(0, -1), // South  
            new Vector2Int(1, 0),  // East
            new Vector2Int(-1, 0)  // West
        };

        foreach (var dir in directions)
        {
            Vector2Int checkPos = doorPos + dir;
            bool isRoom = layout.GetRoomAtPosition(checkPos) != null;
            
            // If this direction leads to a room, the door should face away from it
            if (isRoom)
            {
                // Door should face OPPOSITE the room (toward corridor)
                return GetRotationFromDirection(-dir);
            }
        }

        // Ultimate fallback: face north
        return Quaternion.Euler(0, 0, 0);
    }

    private Quaternion GetRotationFromDirection(Vector2Int direction)
    {
        // Doors should be parallel to the wall they're on
        // If door is on north/south wall, it should face east/west (90° rotation)
        // If door is on east/west wall, it should face north/south (0° rotation)
        
        if (direction == new Vector2Int(0, 1) || direction == new Vector2Int(0, -1)) 
            return Quaternion.Euler(0, 90, 0);   // North/South walls - face east/west
        else 
            return Quaternion.Euler(0, 0, 0);    // East/West walls - face north/south
    }

    private RoomModel FindAdjacentRoom(LevelModel layout, Vector2Int doorPos)
    {
        Vector2Int[] checkDirections = new Vector2Int[]
        {
            new Vector2Int(0, 1), new Vector2Int(0, -1),
            new Vector2Int(1, 0), new Vector2Int(-1, 0)
        };

        foreach (var dir in checkDirections)
        {
            var room = layout.GetRoomAtPosition(doorPos + dir);
            if (room != null) return room;
        }
        
        return null;
    }

    private Quaternion GetDoorRotationFromRoom(RoomModel room, Vector2Int doorPos)
    {
        var bounds = room.Bounds;
        
        // Determine which wall the door is on and make door parallel to that wall
        if (doorPos.y == bounds.yMax - 1 || doorPos.y == bounds.yMin) 
            return Quaternion.Euler(0, 90, 0);   // North/South wall - face east/west
        else 
            return Quaternion.Euler(0, 0, 0);    // East/West wall - face north/south
    }

    private Quaternion GetWallRotation(WallType wallType)
    {
        return wallType switch
        {
            WallType.North => Quaternion.Euler(0, 0, 0),
            WallType.South => Quaternion.Euler(0, 180, 0),
            WallType.East => Quaternion.Euler(0, 90, 0),
            WallType.West => Quaternion.Euler(0, 270, 0),
            _ => Quaternion.identity
        };
    }

    private Material CreateOneSidedMirrorMaterial()
    {
        // Create a material that's transparent in editor but opaque at runtime
        Material material = new Material(Shader.Find("Standard"));
        
        #if UNITY_EDITOR
        // Transparent cyan in editor so you can see through it
        material.color = new Color(0, 1, 1, 0.3f); // Cyan, semi-transparent
        material.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
        material.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
        material.SetInt("_ZWrite", 0);
        material.DisableKeyword("_ALPHATEST_ON");
        material.EnableKeyword("_ALPHABLEND_ON");
        material.DisableKeyword("_ALPHAPREMULTIPLY_ON");
        material.renderQueue = 3000;
        #else
        // Opaque at runtime
        material.color = Color.gray; // Or your ceiling color
        material.SetFloat("_Metallic", 0.1f);
        material.SetFloat("_Glossiness", 0.1f);
        #endif

        return material;
    }

    private void RenderWallsAsPrimitives(LevelModel layout, Transform parent)
    {
        // Fallback: Create primitive cubes if prefabs aren't available
        foreach (var wallPos in layout.AllWallTiles)
        {
            GameObject wall = GameObject.CreatePrimitive(PrimitiveType.Cube);
            wall.transform.position = new Vector3(wallPos.x + 0.5f, 4.5f, wallPos.y + 0.5f);
            wall.transform.localScale = new Vector3(1f, 8f, 1f);
            wall.transform.SetParent(parent);
            wall.name = $"Wall_{wallPos.x}_{wallPos.y}";
            
            // FIX: Use sharedMaterial to avoid material leaks
            Renderer renderer = wall.GetComponent<Renderer>();
            if (Application.isPlaying)
            {
                renderer.material = new Material(Shader.Find("Standard"));
                renderer.material.color = Color.gray;
            }
            else
            {
                Material sharedMaterial = new Material(Shader.Find("Standard"));
                sharedMaterial.color = Color.gray;
                renderer.sharedMaterial = sharedMaterial;
            }
        }
    }

    private void RenderFloorsAsPrimitives(LevelModel layout, Transform parent)
    {
        Debug.Log("Using primitive fallback for floor rendering");
        
        foreach (var floorPos in layout.AllFloorTiles)
        {
            GameObject floor = GameObject.CreatePrimitive(PrimitiveType.Cube);
            floor.transform.position = new Vector3(floorPos.x + 0.5f, 0.5f, floorPos.y + 0.5f);
            floor.transform.localScale = new Vector3(1f, 1f, 1f);
            floor.transform.SetParent(parent);
            floor.name = $"Floor_{floorPos.x}_{floorPos.y}";
            
            // FIX: Use sharedMaterial to avoid material leaks
            Renderer renderer = floor.GetComponent<Renderer>();
            if (Application.isPlaying)
            {
                renderer.material = new Material(Shader.Find("Standard"));
                renderer.material.color = Color.white;
            }
            else
            {
                Material sharedMaterial = new Material(Shader.Find("Standard"));
                sharedMaterial.color = Color.white;
                renderer.sharedMaterial = sharedMaterial;
            }
            
            // Add collision
            floor.AddComponent<BoxCollider>();
        }
        
        Debug.Log($"Created {layout.AllFloorTiles.Count} primitive floors as fallback");
    }
    #endregion
}

// PrefabDoorRenderer.cs
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Renders doors in Real mode using actual prefabs for gameplay.
/// Supports biome themes and proper door placement.
/// </summary>
public class PrefabDoorRenderer : IDoorRenderer
{
    private GameObject _fallbackDoorPrefab;
    private MaterialManager _materialManager;
    private BiomeManager _biomeManager;
    private BiomeTheme _currentTheme;

    public PrefabDoorRenderer(GameObject doorPrefab, MaterialManager materialManager, BiomeManager biomeManager)
    {
        _fallbackDoorPrefab = doorPrefab;
        _materialManager = materialManager;
        _biomeManager = biomeManager;
    }

    /// <summary>
    /// Sets the current biome theme for prefab selection.
    /// </summary>
    public void SetTheme(BiomeTheme theme)
    {
        _currentTheme = theme;
    }

    /// <summary>
    /// Renders all doors as individual prefab instances.
    /// </summary>
    public void RenderDoors(LevelModel layout, Transform parent, bool enableCollision)
    {
        if (layout?.AllDoorTiles == null)
        {
            Debug.LogError("Cannot render prefab doors: layout or door tiles is null");
            return;
        }
        
        int doorsCreated = 0;
        foreach (var doorPos in layout.AllDoorTiles)
        {
            // Use the current theme's door prefab
            var doorPrefab = _biomeManager.GetDoorPrefab(_currentTheme);
            var door = CreateDoorAtPosition(doorPos, doorPrefab);
            
            if (door != null)
            {
                door.transform.SetParent(parent);
                
                if (enableCollision) 
                {
                    AddCollisionToObject(door, "Door");
                }
                
                doorsCreated++;
            }
        }

        Debug.Log($"Created {doorsCreated} prefab doors");
    }

    private GameObject CreateDoorAtPosition(Vector2Int gridPos, GameObject prefab)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 0f, gridPos.y + 0.5f); // Door at floor level
        
        // Use the biome-specific prefab if available, otherwise use fallback
        GameObject doorPrefabToUse = prefab ?? _fallbackDoorPrefab;
        
        if (doorPrefabToUse == null)
        {
            Debug.LogWarning("No door prefab available!");
            return null;
        }
        
        var door = Object.Instantiate(doorPrefabToUse, worldPos, Quaternion.identity);
        door.name = $"Door_{gridPos.x}_{gridPos.y}";
        
        return door;
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;

        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();

        if (objectType == "Door")
        {
            var rb = obj.GetComponent<Rigidbody>();
            if (rb == null)
            {
                rb = obj.AddComponent<Rigidbody>();
                rb.isKinematic = true;
            }
        }
    }
}

// PrefabFloorRenderer.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Renders floors in Real mode using actual prefabs for gameplay.
/// Supports biome themes and individual prefab instantiation.
/// </summary>
public class PrefabFloorRenderer : IFloorRenderer
{
    private GameObject _fallbackFloorPrefab;
    private MaterialManager _materialManager;
    private BiomeManager _biomeManager;
    private BiomeTheme _currentTheme;

    public PrefabFloorRenderer(GameObject floorPrefab, MaterialManager materialManager, BiomeManager biomeManager)
    {
        _fallbackFloorPrefab = floorPrefab;
        _materialManager = materialManager;
        _biomeManager = biomeManager;
    }

    /// <summary>
    /// Sets the current biome theme for prefab selection.
    /// </summary>
    public void SetTheme(BiomeTheme theme)
    {
        _currentTheme = theme;
    }

    /// <summary>
    /// Renders floors as combined meshes (not typically used in Real mode with prefabs).
    /// </summary>
    public List<GameObject> RenderCombinedFloorsByRoomType(LevelModel layout, List<RoomModel> rooms, Transform parent)
    {
        // In real mode with prefabs, we typically don't combine meshes
        // But we'll return empty list for interface compliance
        RenderIndividualFloors(layout, rooms, parent, false);
        return new List<GameObject>();
    }

    /// <summary>
    /// Renders floors as individual prefab instances.
    /// </summary>
    public void RenderIndividualFloors(LevelModel layout, List<RoomModel> rooms, Transform parent, bool enableCollision)
    {
        if (layout?.AllFloorTiles == null)
        {
            Debug.LogError("Cannot render prefab floors: layout or floor tiles is null");
            return;
        }

        int floorsCreated = 0;
        foreach (var floorPos in layout.AllFloorTiles)
        {
            var floorPrefab = _biomeManager.GetFloorPrefab(_currentTheme);
            var floor = CreateFloorAtPosition(floorPos, floorPrefab);
            
            if (floor != null)
            {
                floor.transform.SetParent(parent);
                
                if (enableCollision)
                    AddCollisionToObject(floor, "Floor");
                
                floorsCreated++;
            }
        }

        Debug.Log($"Created {floorsCreated} prefab floors");
    }

    private GameObject CreateFloorAtPosition(Vector2Int gridPos, GameObject prefab)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 0f, gridPos.y + 0.5f);
        
        // Use the biome-specific prefab if available, otherwise use fallback
        GameObject floorPrefabToUse = prefab ?? _fallbackFloorPrefab;
        
        if (floorPrefabToUse == null)
        {
            Debug.LogWarning("No floor prefab available!");
            return null;
        }
        
        var floor = Object.Instantiate(floorPrefabToUse, worldPos, Quaternion.identity);
        floor.name = $"Floor_{gridPos.x}_{gridPos.y}";
        
        return floor;
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;
        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();
    }
}

// PrefabWallRenderer.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Renders walls in Real mode using actual prefabs for gameplay.
/// Supports biome themes and proper wall orientation.
/// </summary>
public class PrefabWallRenderer : IWallRenderer
{
    private GameObject _fallbackWallPrefab;
    private MaterialManager _materialManager;
    private BiomeManager _biomeManager;
    private BiomeTheme _currentTheme;

    public PrefabWallRenderer(GameObject wallPrefab, MaterialManager materialManager, BiomeManager biomeManager)
    {
        _fallbackWallPrefab = wallPrefab;
        _materialManager = materialManager;
        _biomeManager = biomeManager;
    }

    /// <summary>
    /// Sets the current biome theme for prefab selection.
    /// </summary>
    public void SetTheme(BiomeTheme theme)
    {
        _currentTheme = theme;
    }

    /// <summary>
    /// Renders walls as combined meshes (not typically used in Real mode with prefabs).
    /// </summary>
    public List<GameObject> RenderCombinedWallsByType(LevelModel layout, Transform parent)
    {
        // In real mode with prefabs, we typically don't combine meshes
        // But we'll return empty list for interface compliance
        RenderIndividualWalls(layout, parent, false);
        return new List<GameObject>();
    }

    /// <summary>
    /// Renders walls as individual prefab instances with proper orientation.
    /// </summary>
    public void RenderIndividualWalls(LevelModel layout, Transform parent, bool enableCollision)
    {
        if (layout?.AllWallTiles == null || layout.WallTypes == null)
        {
            Debug.LogError("Cannot render prefab walls: layout data is null");
            return;
        }

        int wallsCreated = 0;
        foreach (var wallPos in layout.AllWallTiles)
        {
            if (layout.WallTypes.TryGetValue(wallPos, out var wallType))
            {
                var wallPrefab = _biomeManager.GetWallPrefab(_currentTheme);
                var wall = CreateWallAtPosition(wallPos, wallType, wallPrefab);
                
                if (wall != null)
                {
                    wall.transform.SetParent(parent);
                    
                    if (enableCollision)
                        AddCollisionToObject(wall, "Wall");
                    
                    wallsCreated++;
                }
            }
        }

        Debug.Log($"Created {wallsCreated} prefab walls");
    }

    private GameObject CreateWallAtPosition(Vector2Int gridPos, WallType wallType, GameObject prefab)
    {
        Vector3 worldPos = new Vector3(gridPos.x + 0.5f, 1f, gridPos.y + 0.5f); // Walls at 1 unit height
        
        // Use the biome-specific prefab if available, otherwise use fallback
        GameObject wallPrefabToUse = prefab ?? _fallbackWallPrefab;
        
        if (wallPrefabToUse == null)
        {
            Debug.LogWarning("No wall prefab available!");
            return null;
        }
        
        var wall = Object.Instantiate(wallPrefabToUse, worldPos, Quaternion.identity);
        wall.name = $"Wall_{wallType}_{gridPos.x}_{gridPos.y}";
        
        // Apply wall rotation for better visual alignment
        ApplyWallRotation(wall, wallType);
        
        return wall;
    }

    private void ApplyWallRotation(GameObject wall, WallType wallType)
    {
        if (wall == null) return;

        // Adjust rotation based on wall type for better visual presentation
        Quaternion rotation = GetWallRotation(wallType);
        wall.transform.rotation = rotation;
    }

    private Quaternion GetWallRotation(WallType wallType)
    {
        return wallType switch
        {
            WallType.North => Quaternion.Euler(0, 0, 0),
            WallType.South => Quaternion.Euler(0, 180, 0),
            WallType.East => Quaternion.Euler(0, 90, 0),
            WallType.West => Quaternion.Euler(0, 270, 0),
            WallType.Corridor => Quaternion.Euler(0, 0, 0), // Corridor walls might need special handling
            _ => Quaternion.identity
        };
    }

    private void AddCollisionToObject(GameObject obj, string objectType)
    {
        if (obj == null) return;
        if (obj.GetComponent<Collider>() == null)
            obj.AddComponent<BoxCollider>();
    }
}

// SpecialRoomRenderer.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Renders special room objects (entrance, exit, shop, treasure, boss) using prefabs.
/// Supports biome themes and proper object placement.
/// </summary>
public class SpecialRoomRenderer
{
    private GameObject _defaultEntrancePrefab;
    private GameObject _defaultExitPrefab;
    private BiomeManager _biomeManager;
    private BiomeTheme _currentTheme;

    public SpecialRoomRenderer(GameObject entrancePrefab, GameObject exitPrefab, BiomeManager biomeManager)
    {
        _defaultEntrancePrefab = entrancePrefab;
        _defaultExitPrefab = exitPrefab;
        _biomeManager = biomeManager;
    }

    /// <summary>
    /// Sets the current biome theme for special room prefab selection.
    /// </summary>
    public void SetTheme(BiomeTheme theme)
    {
        _currentTheme = theme;
    }

    /// <summary>
    /// Renders special objects for all special rooms in the level.
    /// </summary>
    public void RenderSpecialObjects(LevelModel layout, List<RoomModel> rooms, Transform parent)
    {
        if (rooms == null || parent == null)
        {
            Debug.LogError("Cannot render special objects: rooms or parent is null");
            return;
        }

        int specialObjectsCreated = 0;
        foreach (var room in rooms)
        {
            if (room != null && IsSpecialRoomType(room.Type))
            {
                if (RenderRoomSpecialObject(room, parent))
                {
                    specialObjectsCreated++;
                }
            }
        }

        Debug.Log($"Created {specialObjectsCreated} special room objects");
    }

    private bool IsSpecialRoomType(RoomType roomType)
    {
        return roomType == RoomType.Entrance || roomType == RoomType.Exit || 
               roomType == RoomType.Shop || roomType == RoomType.Treasure || 
               roomType == RoomType.Boss;
    }

    private bool RenderRoomSpecialObject(RoomModel room, Transform parent)
    {
        GameObject prefab = GetSpecialRoomPrefab(room.Type);

        // Fallback to default prefabs if biome doesn't provide one
        if (prefab == null)
        {
            prefab = GetDefaultSpecialRoomPrefab(room.Type);
        }

        if (prefab != null)
        {
            Vector3 position = new Vector3(room.Center.x, 0, room.Center.y);
            var specialObject = Object.Instantiate(prefab, position, Quaternion.identity, parent);
            specialObject.name = $"{room.Type}_{room.ID}";
            return true;
        }
        else
        {
            Debug.LogWarning($"No prefab available for {room.Type} room {room.ID}");
            return false;
        }
    }

    private GameObject GetSpecialRoomPrefab(RoomType roomType)
    {
        if (_currentTheme == null) return null;

        return roomType switch
        {
            RoomType.Entrance => _biomeManager.GetPrefab(_currentTheme.EntrancePrefabPath),
            RoomType.Exit => _biomeManager.GetPrefab(_currentTheme.ExitPrefabPath),
            RoomType.Shop => _biomeManager.GetPrefab(_currentTheme.ShopPrefabPath),
            RoomType.Treasure => _biomeManager.GetPrefab(_currentTheme.TreasurePrefabPath),
            RoomType.Boss => _biomeManager.GetPrefab(_currentTheme.BossPrefabPath),
            _ => null
        };
    }

    private GameObject GetDefaultSpecialRoomPrefab(RoomType roomType)
    {
        return roomType switch
        {
            RoomType.Entrance => _defaultEntrancePrefab,
            RoomType.Exit => _defaultExitPrefab,
            _ => null // Only entrance/exit have default fallbacks
        };
    }
}