// GeometryBuilder.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Builds the final geometry for a dungeon level by processing rooms, corridors, walls, and doors.
/// </summary>
public class GeometryBuilder
{
    /// <summary>
    /// Constructs the complete geometry for the dungeon layout.
    /// </summary>
    public void BuildFinalGeometry(LevelModel layout)
    {
        if (layout == null)
        {
            Debug.LogError("Cannot build geometry - layout is null!");
            return;
        }

        ClearLayoutData(layout);
        BuildFloorGeometry(layout);
        BuildWallGeometry(layout);
        
        Debug.Log($"Geometry built: {layout.Rooms.Count} rooms, {layout.AllFloorTiles.Count} floor tiles");
    }
    
    private void ClearLayoutData(LevelModel layout)
    {
        layout.AllFloorTiles.Clear();
        layout.AllWallTiles.Clear();
        layout.AllDoorTiles.Clear();
        layout.WallTypes.Clear();
    }

    private void BuildFloorGeometry(LevelModel layout)
    {
        var allFloorTiles = new HashSet<Vector2Int>();
        int roomsProcessed = 0;
        int corridorTilesProcessed = 0;

        // Process room floors
        foreach (var room in layout.Rooms.Where(room => room != null))
        {
            try 
            {
                var roomFloors = room.GetFloorTiles();
                int roomFloorCount = AddRoomFloorsToSet(roomFloors, allFloorTiles);
                roomsProcessed++;
                
                Debug.Log($"Room {room.ID} ({room.Type}): added {roomFloorCount} floor tiles");
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Error processing room {room?.ID}: {ex.Message}");
            }
        }

        // Process corridor floors
        corridorTilesProcessed = AddCorridorFloorsToSet(layout.Corridors, allFloorTiles);

        layout.AllFloorTiles = allFloorTiles;
    }

    private int AddRoomFloorsToSet(IEnumerable<Vector2Int> roomFloors, HashSet<Vector2Int> floorSet)
    {
        int count = 0;
        foreach (var floorPos in roomFloors)
        {
            floorSet.Add(floorPos);
            count++;
        }
        return count;
    }

    private int AddCorridorFloorsToSet(List<CorridorModel> corridors, HashSet<Vector2Int> floorSet)
    {
        int count = 0;
        foreach (var corridor in corridors.Where(c => c?.Tiles != null))
        {
            foreach (var tile in corridor.Tiles)
            {
                floorSet.Add(tile);
                count++;
            }
        }
        return count;
    }
    
    private void BuildWallGeometry(LevelModel layout)
    {
        BuildWallsWithTypes(layout);
    }

    private void BuildWallsWithTypes(LevelModel layout)
    {
        var allWalls = new HashSet<Vector2Int>();
        var wallTypes = new Dictionary<Vector2Int, WallType>();

        // Build walls in stages
        var roomWallPerimeters = BuildRoomWalls(layout, allWalls);
        BuildCorridorWalls(layout, allWalls, roomWallPerimeters);
        ProcessDoorsAndWallTypes(layout, allWalls, wallTypes, roomWallPerimeters);

        layout.AllWallTiles = allWalls;
        layout.WallTypes = wallTypes;
    }

    private Dictionary<RoomModel, HashSet<Vector2Int>> BuildRoomWalls(LevelModel layout, HashSet<Vector2Int> allWalls)
    {
        var roomWallPerimeters = new Dictionary<RoomModel, HashSet<Vector2Int>>();
        
        foreach (var room in layout.Rooms.Where(room => room != null))
        {
            var wallPerimeter = new HashSet<Vector2Int>(room.GetWallPerimeter());
            roomWallPerimeters[room] = wallPerimeter;
            allWalls.UnionWith(wallPerimeter);
        }

        return roomWallPerimeters;
    }

    private void BuildCorridorWalls(LevelModel layout, HashSet<Vector2Int> allWalls, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        foreach (var corridor in layout.Corridors.Where(c => c?.Tiles != null))
        {
            foreach (var corridorTile in corridor.Tiles)
            {
                AddWallsAroundCorridorTile(corridorTile, layout.AllFloorTiles, allWalls, roomWallPerimeters, layout.Rooms);
            }
        }
    }

    private void AddWallsAroundCorridorTile(Vector2Int corridorTile, HashSet<Vector2Int> floorTiles, HashSet<Vector2Int> allWalls, 
                                          Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters, List<RoomModel> rooms)
    {
        foreach (var neighbor in GetCardinalNeighbors(corridorTile))
        {
            // Add wall if position is not a floor tile and not already a wall
            if (!floorTiles.Contains(neighbor) && !allWalls.Contains(neighbor))
            {
                allWalls.Add(neighbor);
                AddToRoomWallPerimeter(neighbor, rooms, roomWallPerimeters);
            }
        }
    }

    private void AddToRoomWallPerimeter(Vector2Int wallPosition, List<RoomModel> rooms, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        var room = GetRoomAtPosition(wallPosition, rooms);
        if (room != null && roomWallPerimeters.ContainsKey(room))
        {
            roomWallPerimeters[room].Add(wallPosition);
        }
    }

    private void ProcessDoorsAndWallTypes(LevelModel layout, HashSet<Vector2Int> allWalls, Dictionary<Vector2Int, WallType> wallTypes, 
                                        Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        RemoveDoorPositionsFromWalls(layout, allWalls, roomWallPerimeters);
        DetermineWallTypes(layout, allWalls, wallTypes);
    }

    private void RemoveDoorPositionsFromWalls(LevelModel layout, HashSet<Vector2Int> allWalls, Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters)
    {
        foreach (var corridor in layout.Corridors.Where(IsValidCorridor))
        {
            RemoveDoorPosition(corridor.StartDoorPosition, corridor.StartRoom, allWalls, roomWallPerimeters, layout);
            RemoveDoorPosition(corridor.EndDoorPosition, corridor.EndRoom, allWalls, roomWallPerimeters, layout);
        }
    }

    private bool IsValidCorridor(CorridorModel corridor)
    {
        return corridor?.StartRoom != null && corridor?.EndRoom != null;
    }

    private void RemoveDoorPosition(Vector2Int doorPosition, RoomModel room, HashSet<Vector2Int> allWalls, 
                                  Dictionary<RoomModel, HashSet<Vector2Int>> roomWallPerimeters, LevelModel layout)
    {
        if (roomWallPerimeters.ContainsKey(room))
        {
            roomWallPerimeters[room].Remove(doorPosition);
        }
        
        allWalls.Remove(doorPosition);
        layout.AllDoorTiles.Add(doorPosition);
    }

    private void DetermineWallTypes(LevelModel layout, HashSet<Vector2Int> allWalls, Dictionary<Vector2Int, WallType> wallTypes)
    {
        foreach (var wallPos in allWalls)
        {
            wallTypes[wallPos] = WallTypeCalculator.DetermineWallType(wallPos, layout.Rooms, layout.AllFloorTiles);
        }
    }

    private List<Vector2Int> GetCardinalNeighbors(Vector2Int pos)
    {
        return new List<Vector2Int>
        {
            new Vector2Int(pos.x + 1, pos.y),     // Right
            new Vector2Int(pos.x - 1, pos.y),     // Left
            new Vector2Int(pos.x, pos.y + 1),     // Up
            new Vector2Int(pos.x, pos.y - 1)      // Down
        };
    }

    private RoomModel GetRoomAtPosition(Vector2Int position, List<RoomModel> rooms)
    {
        return rooms.FirstOrDefault(room => room.ContainsPosition(position));
    }
}

// WallTypeCalculator.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Determines the specific type of wall (corner, edge, interior, etc.) based on position and context.
/// </summary>
public static class WallTypeCalculator
{
    /// <summary>
    /// Determines the wall type for a given position based on room geometry and adjacent tiles.
    /// </summary>
    public static WallType DetermineWallType(Vector2Int pos, List<RoomModel> rooms, HashSet<Vector2Int> allFloorTiles)
    {
        // Check for corridor walls first
        if (IsCorridorWall(pos, rooms, allFloorTiles))
        {
            return WallType.Corridor;
        }

        // Then check for room perimeter walls
        var roomWallType = DetermineRoomWallType(pos, rooms);
        if (roomWallType != WallType.Interior)
        {
            return roomWallType;
        }

        // Default to interior wall
        return WallType.Interior;
    }

    private static bool IsCorridorWall(Vector2Int pos, List<RoomModel> rooms, HashSet<Vector2Int> allFloorTiles)
    {
        bool adjacentToCorridor = IsAdjacentToCorridor(pos, allFloorTiles, rooms);
        bool isRoomPerimeter = IsPartOfRoomPerimeter(pos, rooms);
        
        return adjacentToCorridor && !isRoomPerimeter;
    }

    private static bool IsAdjacentToCorridor(Vector2Int pos, HashSet<Vector2Int> allFloorTiles, List<RoomModel> rooms)
    {
        return GetCardinalNeighbors(pos).Any(neighbor => 
            allFloorTiles.Contains(neighbor) && !IsInAnyRoom(neighbor, rooms));
    }

    private static bool IsPartOfRoomPerimeter(Vector2Int pos, List<RoomModel> rooms)
    {
        foreach (var room in rooms.Where(room => room?.Bounds != null))
        {
            if (IsOnRoomEdge(pos, room) && room.ContainsPosition(new Vector2Int(pos.x, pos.y)))
            {
                return true;
            }
        }
        return false;
    }

    private static WallType DetermineRoomWallType(Vector2Int pos, List<RoomModel> rooms)
    {
        foreach (var room in rooms.Where(room => room?.Bounds != null))
        {
            if (!IsOnRoomEdge(pos, room) || !room.ContainsPosition(new Vector2Int(pos.x, pos.y)))
                continue;

            return GetSpecificWallType(pos, room);
        }

        return WallType.Interior;
    }

    private static bool IsOnRoomEdge(Vector2Int pos, RoomModel room)
    {
        var bounds = room.Bounds;
        return pos.y == bounds.yMax - 1 || pos.y == bounds.yMin || 
               pos.x == bounds.xMax - 1 || pos.x == bounds.xMin;
    }

    private static WallType GetSpecificWallType(Vector2Int pos, RoomModel room)
    {
        var bounds = room.Bounds;
        bool isNorth = pos.y == bounds.yMax - 1;
        bool isSouth = pos.y == bounds.yMin;
        bool isEast = pos.x == bounds.xMax - 1;
        bool isWest = pos.x == bounds.xMin;

        // Check corners first
        if (isNorth && isWest) return WallType.NorthWestCorner;
        if (isNorth && isEast) return WallType.NorthEastCorner;
        if (isSouth && isWest) return WallType.SouthWestCorner;
        if (isSouth && isEast) return WallType.SouthEastCorner;
        
        // Then edges
        if (isNorth) return WallType.North;
        if (isSouth) return WallType.South;
        if (isEast) return WallType.East;
        if (isWest) return WallType.West;

        return WallType.Interior;
    }

    private static bool IsInAnyRoom(Vector2Int position, List<RoomModel> rooms)
    {
        return rooms.Any(room => room?.ContainsPosition(position) == true);
    }

    private static List<Vector2Int> GetCardinalNeighbors(Vector2Int pos)
    {
        return new List<Vector2Int>
        {
            new Vector2Int(pos.x + 1, pos.y),     // Right
            new Vector2Int(pos.x - 1, pos.y),     // Left
            new Vector2Int(pos.x, pos.y + 1),     // Up
            new Vector2Int(pos.x, pos.y - 1)      // Down
        };
    }
}